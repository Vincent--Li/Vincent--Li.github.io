<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>怕什么真理无穷,进一寸有一寸的欢喜</title>
  
  
  <link href="https://vincent--li.github.io/atom.xml" rel="self"/>
  
  <link href="https://vincent--li.github.io/"/>
  <updated>2022-09-16T16:12:29.865Z</updated>
  <id>https://vincent--li.github.io/</id>
  
  <author>
    <name>Vincent Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Tutorial</title>
    <link href="https://vincent--li.github.io/2022/09/16/hello-world/"/>
    <id>https://vincent--li.github.io/2022/09/16/hello-world/</id>
    <published>2022-09-15T19:22:00.000Z</published>
    <updated>2022-09-16T16:12:29.865Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;to past image </span><br><span class="line">&#123;% asset<span class="emphasis">_img filename image_</span>description %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://vincent--li.github.io/tags/hexo/"/>
    
    <category term="test" scheme="https://vincent--li.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Java Class文件结构</title>
    <link href="https://vincent--li.github.io/2019/08/01/Java%20Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://vincent--li.github.io/2019/08/01/Java%20Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2019-07-31T16:59:28.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="语言无关性"><a href="#语言无关性" class="headerlink" title="语言无关性"></a>语言无关性</h3><pre class="mermaid">graph LRA(*.java)-->D(.class)B(*.rb)-->DC(*.groovy)-->DE(其它JVM语言)-->DD-->F(JVM)</pre><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>u1 &#x3D; 1byte</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h4 id="magic-u4"><a href="#magic-u4" class="headerlink" title="magic u4"></a>magic u4</h4><ul><li>0xCAFEEBABE</li></ul><h4 id="constant-pool-count-u2"><a href="#constant-pool-count-u2" class="headerlink" title="constant_pool_count u2"></a>constant_pool_count u2</h4><p>常量池中, 常量的个数</p><h4 id="constant-pool-cp-info"><a href="#constant-pool-cp-info" class="headerlink" title="constant_pool cp_info"></a>constant_pool cp_info</h4><ul><li>CONSTANT_Utf8 1 UTF-8编码的Unicode字符串</li><li>CONSTANT_Integer 3 int类型的字面值</li><li>CONSTANT_Float 4 float类型的字面值</li><li>CONSTANT_Long 5 long类型的字面值</li><li>CONSTANT_Double 6 double类型的字面值</li><li>CONSTANT_Class 7 对一个类或接口的符号引用</li><li>CONSTANT_String 8 String类型字面值的引用</li><li>CONSTANT_Fieldref 9 对一个字段的符号引用</li><li>CONSTANT_Methodref 10 对一个类中方法的符号引用</li><li>CONSTANT_InterfaceMethodref 11 对一个接口中方法的符号引用</li><li>CONSTANT_NameAndType 12 对一个字段或方法的部分符号引用</li></ul><h4 id="access-flag-u2-类的标示符"><a href="#access-flag-u2-类的标示符" class="headerlink" title="access flag u2: 类的标示符"></a>access flag u2: 类的标示符</h4><table><thead><tr><th>flag name</th><th>value</th><th>interpretation</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>final,不能被继承</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial指令,jdk1.2后,该值为true</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>是否是接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>抽象类</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>该类不是由用户代码生成,运行时生成的,没有源码</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>是否为注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>是否为枚举</td></tr></tbody></table><h4 id="this-class-u2"><a href="#this-class-u2" class="headerlink" title="this_class u2"></a>this_class u2</h4><ul><li>指向常量池的Class</li></ul><h4 id="super-class-u2"><a href="#super-class-u2" class="headerlink" title="super_class u2"></a>super_class u2</h4><ul><li>指向常量池的Class</li></ul><h4 id="interface-count-u2"><a href="#interface-count-u2" class="headerlink" title="interface_count u2"></a>interface_count u2</h4><ul><li>接口数量</li></ul><h4 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h4><ul><li>interfaces_count 个interface u2</li><li>每个interface是指向CONSTANT_Class的索引</li></ul><h4 id="field-count"><a href="#field-count" class="headerlink" title="field_count"></a>field_count</h4><ul><li>字段数量</li></ul><h4 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h4><ul><li>field_count个field_info</li></ul><h4 id="field"><a href="#field" class="headerlink" title="field"></a>field</h4><ul><li>access_flags u2</li><li>name_index u2</li><li>descriptor_index u2</li><li>attributes_count u2</li><li>attribute_info attributes[attributes_count];</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;语言无关性&quot;&gt;&lt;a href=&quot;#语言无关性&quot; class=&quot;headerlink&quot; title=&quot;语言无关性&quot;&gt;&lt;/a&gt;语言无关性&lt;/h3&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
A(*.java)--&gt;D(.class)
B(*.rb)--</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
    <category term="Class文件" scheme="https://vincent--li.github.io/tags/Class%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM锁</title>
    <link href="https://vincent--li.github.io/2019/07/20/JVM%E9%94%81/"/>
    <id>https://vincent--li.github.io/2019/07/20/JVM%E9%94%81/</id>
    <published>2019-07-20T13:26:30.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="多线程网站统计访问人数"><a href="#多线程网站统计访问人数" class="headerlink" title="多线程网站统计访问人数"></a>多线程网站统计访问人数</h4><ul><li>使用锁, 维护计数器的串行访问与安全性</li><li>多线程方位ArrayList<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AddToList</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> startnum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddToList</span><span class="params">(<span class="type">int</span> startnumber)</span>&#123;</span><br><span class="line">        startnum=startnumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;<span class="number">1000000</span>)&#123;</span><br><span class="line">            numberList.add(startnum);</span><br><span class="line">            startnum+=<span class="number">2</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">AddToList</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">AddToList</span>(<span class="number">1</span>));</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="keyword">while</span>(t1.isAlive()||t2.isAlive())&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(numberList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象头Mark"><a href="#对象头Mark" class="headerlink" title="对象头Mark"></a>对象头Mark</h3><ul><li>Mark Word , 对象头的标记, 32位</li><li>描述对象的hash, 锁信息, 垃圾回收标记, 年龄<ul><li>指向锁记录的指针</li><li>指向monitor的治身</li><li>GC标记</li><li>偏向锁线程ID</li></ul></li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li>大部分情况是没有竞争的, 所以可以通过偏向来提高性能</li><li>所谓偏向, 就是偏心, 即锁会偏向于当前已经占有锁的线程</li><li>将对象头Mark标记设置为偏向, 并将线程ID写入对象头Mark</li><li>只要没有竞争, 获得偏向锁的线程,在将来进入同步块,不需要做同步</li><li>当其他线程请求相同的锁时, 偏向模式结束</li><li>-XX:+UseBiasedLocking 默认启用</li><li>在竞争激烈的场合, 偏向锁会增加系统负担</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; numberList = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> voi <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMills();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startnum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt; <span class="number">10000000</span>)&#123;</span><br><span class="line">        numberLis.add(startnum);</span><br><span class="line">        startnum+=<span class="number">2</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(end-begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>BasicObjectLock</li><li>嵌在线程栈中的对象<pre class="mermaid">graph LRA(BasicObjectLock)-->B(BasicLock)B-->C(markOop_displaced_header)A-->D(ptr to obj hold the lock)</pre></li><li>普通锁的处理性能不够理想,轻量级锁是一种快速锁定的方法</li><li>如果对象没有被锁定</li></ul><ol><li>将对象头的Mark指针保存到锁对象</li><li>将对象头设置为指向锁的指针(在线程栈空间中)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock-&gt;set_displaced_header(mark);</span><br><span class="line"><span class="keyword">if</span>(mark== (markOop)Atomic::cmpxchg_ptr(lock,obj()-&gt;mark_addr(),mark))&#123;</span><br><span class="line">    TEVENT(slow_enter: release stacklock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>如果轻量级锁失败,表示存在竞争,升级为重量级锁(常规锁)</li><li>在没有锁竞争的前提下,减少传统锁使用OS互斥产生的性能损耗</li><li>在竞争激烈时,轻量级锁会做很多额外操作,导致性能下降</li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul><li>当竞争存在时, 如果香橙可以很快获得锁, 那么可以不在OS层挂起线程, 让线程做几个空操作(自旋)</li><li>JDK 1.6 中通过 -XX:+UseSpinning开启</li><li>JDK 1.7中去掉此参数, 内置默认开启</li><li>如果同步块很长,自旋失败,会降低系统性能</li><li>如果同步块很短,自旋成功, 节省线程挂起切换时间,提升系统性能</li></ul><h3 id="偏向锁-轻量级锁-自旋锁总结"><a href="#偏向锁-轻量级锁-自旋锁总结" class="headerlink" title="偏向锁,轻量级锁,自旋锁总结"></a>偏向锁,轻量级锁,自旋锁总结</h3><ul><li>不是Java语言层面的锁优化方案</li><li>内置于JVM中的获取锁的优化方法和获取锁的步骤</li></ul><ol><li>偏向锁可用会现场时偏向锁</li><li>轻量级锁可用会先尝试轻量级锁</li><li>以上都失败,尝试自旋锁</li><li>再失败,尝试普通锁,使用OS互斥量操作系统层挂起</li></ol><h3 id="java语言层面优化"><a href="#java语言层面优化" class="headerlink" title="java语言层面优化"></a>java语言层面优化</h3><h4 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">syncMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    mutextMethod();</span><br><span class="line">    othercode2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncMethod2</span><span class="params">()</span>&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        mutextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul><li>将大对象,拆成小对象,大大增加并行度,降低锁竞争</li><li>偏向锁, 轻量级锁成功率提高</li><li>ConcurrentHashMap</li><li>HashMap的同步实现</li></ul><ol><li>Collections.synchronizedMap(Map&lt;K,V&gt; m)</li><li>返回SynchronizedMap对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutext)&#123;</span><br><span class="line">        <span class="keyword">return</span> m.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">pug</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutext)&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>ConcurrentHashMap</li></ul><ol><li>分成若干个Segment: Segment&lt;K,V&gt; [] segments</li><li>Segment中维护HashEntry&lt;K,V&gt;</li><li>put操作时: 先定位到Segment, 锁定一个Segment, 执行put</li></ol><ul><li>在减小锁粒度后, ConcurrentHashMap允许若干个线程同时进入</li></ul><h4 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h4><ul><li>根据功能进行锁分离</li><li>ReadWriteLock</li><li>读多写少的情况,可以提高性能</li></ul><table><thead><tr><th>略</th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>可访问</td><td>不可访问</td></tr><tr><td>写锁</td><td>不可访问</td><td>不可访问</td></tr></tbody></table><ul><li>读写分离思想可以延伸, 只要操作互不影响,锁就可以分离</li><li>LinkedBlockingQueue</li></ul><ol><li>队列</li><li>链表</li></ol><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul><li>通常情况下, 为了保证多线程间的有效并发,会要求每个线程持有锁的时间尽量短,即在使用完公共资源后,应该立即释放锁.只有这样,等待在这个锁上的其他线程才能尽早获得资源执行任务. 但是,凡事都有一个度,如果对同一个锁不停的进行请求,同步和释放, 其本身也会消耗系统宝贵资源,反而不利于性能的优化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do sth.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做其他不需要的同步工作,但能很快执行完毕</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do sth.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//整合成一次锁请求</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">        <span class="comment">//do other</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>在即时编译器时,如果发现不可能被共享的对象,则可以消除这些对象的锁操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CIRCLE=2000000</span></span><br><span class="line"><span class="comment">// -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks 187ms</span></span><br><span class="line"><span class="comment">// -server -XX:+DoEscapeAnalysis -XX:-EliminateLocks 254ms</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">        createStringBuffer(<span class="string">&quot;JVM&quot;</span>,<span class="string">&quot;Diagnosis&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">bufferCost</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;createStringBuffer:&quot;</span> + bufferCost + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1); <span class="comment">// append 方法内置synchronize锁,但是这里是失效的</span></span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><ul><li>锁是悲观的操作</li><li>无锁是乐观的操作</li><li>无锁的一种实现方式</li></ul><ol><li>CAS(Compare And Swap)</li><li>非阻塞的同步</li><li>CAS(Valve,Expect,NewValue)</li></ol><ul><li>在应用层面判断多线程的干扰,如果有干扰,则通知线程重试</li><li>java.util.concurrent.atomic.AtomicInteger<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> new Value)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current,newValue))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;h4 id=&quot;多线程网站统计访问人数&quot;&gt;&lt;a href=&quot;#多线程网站统计访问人数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java堆分析</title>
    <link href="https://vincent--li.github.io/2019/07/14/Java%E5%A0%86%E5%88%86%E6%9E%90/"/>
    <id>https://vincent--li.github.io/2019/07/14/Java%E5%A0%86%E5%88%86%E6%9E%90/</id>
    <published>2019-07-14T14:25:46.000Z</published>
    <updated>2022-09-16T16:12:29.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MAT使用基础-Memory-Analyse-Tool"><a href="#MAT使用基础-Memory-Analyse-Tool" class="headerlink" title="MAT使用基础 Memory Analyse Tool"></a>MAT使用基础 Memory Analyse Tool</h3><h4 id="浅堆-Shallow-Heap"><a href="#浅堆-Shallow-Heap" class="headerlink" title="浅堆(Shallow Heap)"></a>浅堆(Shallow Heap)</h4><ul><li>一个对象结构所占用的内存大小</li><li>3个int类型以及一个引用类型合计占用3*4+4&#x3D;16字节, 再加上对象头的8个字节,因此String对象占用的控件,即浅堆的大小是16+8&#x3D;24字节</li><li>对象大小按照8字节对齐</li><li>浅堆大小和对象的内容无关, 只和对象的结构有关</li></ul><h4 id="深堆-Retained-Heap"><a href="#深堆-Retained-Heap" class="headerlink" title="深堆(Retained Heap)"></a>深堆(Retained Heap)</h4><ul><li>一个对象被GC后,可以真实释放的内存大小</li><li>只能通过对象访问到的(直接或者间接)所有对象和浅堆之和(支配树)</li></ul><h4 id="显示入引用-incoming-和出引用-outgoing"><a href="#显示入引用-incoming-和出引用-outgoing" class="headerlink" title="显示入引用(incoming)和出引用(outgoing)"></a>显示入引用(incoming)和出引用(outgoing)</h4><h4 id="支配树"><a href="#支配树" class="headerlink" title="支配树"></a>支配树</h4><ul><li>对象引用图中, 所有指向对象B的路径都经过对象A, 则认为对象A支配对象B</li><li>如果对象A是离对象B最近的一个支配对象,则认为对象A为对象B的直接支配者</li><li>支配者被回收, 被支配者也被回收</li></ul><h4 id="对象引用图"><a href="#对象引用图" class="headerlink" title="对象引用图"></a>对象引用图</h4><pre class="mermaid">graph TDA((A))-->C((C))B((B))-->CC-->D((D))C-->E((E))E-->G((G))G-->H((H))D-->F((F))F-->DF-->H</pre><h4 id="支配树-1"><a href="#支配树-1" class="headerlink" title="支配树"></a>支配树</h4><pre class="mermaid">graph TDroot((root))-->A((A))root-->B((B))root-->C((C))C-->D((D))C-->E((E))C-->H((H))D-->F((F))E-->G((G))</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MAT使用基础-Memory-Analyse-Tool&quot;&gt;&lt;a href=&quot;#MAT使用基础-Memory-Analyse-Tool&quot; class=&quot;headerlink&quot; title=&quot;MAT使用基础 Memory Analyse Tool&quot;&gt;&lt;/a&gt;MAT使用</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能监控工具</title>
    <link href="https://vincent--li.github.io/2019/07/13/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>https://vincent--li.github.io/2019/07/13/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</id>
    <published>2019-07-13T12:59:16.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统性能监控"><a href="#系统性能监控" class="headerlink" title="系统性能监控"></a>系统性能监控</h3><ul><li>uptime</li></ul><ol><li>系统时间</li><li>运行时间</li><li>连接数: 每个终端算一个连接数</li><li>1&#x2F;5&#x2F;15分钟系统平均负载</li></ol><ul><li>top</li></ul><ol><li>第一行同uptime</li><li>cpu内存</li><li>每个进程占CPU的情况</li></ol><ul><li>vmstat</li></ul><ol><li>可以统计系统的CPU, 内存, swap, io等情况</li><li>CPU占用率很高, 上下文切换频繁, 说明系统有线程正在频繁切换</li></ol><ul><li>pidstat</li></ul><ol><li>细致观察进程</li><li>需要安装</li><li>监控CPU</li><li>监控IO</li><li>监控内存</li></ol><h3 id="Java自带工具"><a href="#Java自带工具" class="headerlink" title="Java自带工具"></a>Java自带工具</h3><p>jdk安装目录下的tools目录下. </p><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><ul><li>列出java进程, 类似ps命令</li><li>-q指定jps只输出进程ID, 不输出类的短名称</li><li>-m输出传递给Java进程(主函数)的参数</li><li>-l可以用于输出主函数的完整路径</li><li>-v可以显式传递给JVM的参数</li></ul><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><ul><li>可以用来查看正在运行的Java应用程序的扩展参数, 甚至支持在运行时,修改部分参数</li><li>-flag &lt;name&gt; : 打印指定的JVM的参数值</li><li>-flag [+|-] &lt;name&gt;: 指定JVM参数的布尔值</li><li>-flag &lt;name&gt;&#x3D;&lt;value&gt;: 设置指定JVM参数的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示新生代对象晋升到老年代对象的最大年龄</span></span><br><span class="line">jinfo -flag MaxTenuringThreshold 2972</span><br><span class="line">-XX:MaxTenuringThreshold=15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示是否打印GC详细信息</span></span><br><span class="line">jinfo -flag PrintGCDetails 2972</span><br><span class="line">-XX:-PrintGCDetails</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行时修改参数, 控制是否输出GC日志</span></span><br><span class="line">jinof -flag PrintGCDetails 2972</span><br><span class="line">-XX:-PrintGCDetails</span><br><span class="line"></span><br><span class="line">jinfo -flag +PrintGCDetails 2972</span><br><span class="line"></span><br><span class="line">jinfo -flag PrintGCDetails 2972</span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul><li>生成Java应用程序的堆快照和对象的统计信息</li><li>jmap -histo 2972 &gt;c:\s.txt</li><li>dump堆出来</li><li>jamp -dump:format&#x3D;b,file&#x3D;c:\heap.hprof 2972</li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><ul><li>打印线程dump</li><li>-l打印锁信息</li><li>-m打印java和native的帧信息</li><li>-F强制dump,当jstack没有响应时使用</li></ul><h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><ul><li>图形化监控工具</li><li>可以查看Java应用程序的运行概况, 监控堆信息,永久区使用情况, 类加载情况等</li></ul><h4 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h4><ul><li>jvisualvm</li><li>Visual VM: 是一种功能强大的多合一故障诊断和性能监控工具</li></ul><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li>TProfiler</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;系统性能监控&quot;&gt;&lt;a href=&quot;#系统性能监控&quot; class=&quot;headerlink&quot; title=&quot;系统性能监控&quot;&gt;&lt;/a&gt;系统性能监控&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;uptime&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;系统时间&lt;/li&gt;
&lt;li&gt;运行时间&lt;/l</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
    <category term="监控工具" scheme="https://vincent--li.github.io/tags/%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java 类装载器</title>
    <link href="https://vincent--li.github.io/2019/07/09/Java%20%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/"/>
    <id>https://vincent--li.github.io/2019/07/09/Java%20%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/</id>
    <published>2019-07-09T15:09:04.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="class装载验证流程"><a href="#class装载验证流程" class="headerlink" title="class装载验证流程"></a>class装载验证流程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li>装载类的第一阶段</li><li>取得类的二进制流</li><li>转为方法区数据结构</li><li>在Java堆中生成对应的java.lang.Class对象</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>目的: 保证Class流的格式是正确的</p><ul><li>文件格式的验证</li></ul><ol><li>持否以0xCAFEBABE开头</li><li>版本号时候合理</li></ol><ul><li>元数据验证</li></ul><ol><li>是否有父类</li><li>继承了final类?</li><li>非抽象类是否实现了所有的抽象方法</li></ol><ul><li>字节码验证(很复杂)</li></ul><ol><li>运行检查</li><li>栈数据类型和操作码数据参数吻合</li><li>跳转指令指定到合理的位置</li></ol><ul><li>符号引用验证</li></ul><ol><li>常量池中描述类是否存在</li><li>访问的方法或字段是否存在且有足够的权限</li></ol><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul><li>分配内存,并为类设置初始值(方法区中)</li></ul><ol><li>public static int v&#x3D;1</li><li>在准备阶段中, v会被设置为0</li><li>在初始化的clinit中才会被设置为1</li><li>对于static final类型, 在准备阶段就会被赋为正常的值</li><li>public static final int v&#x3D;1</li></ol><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ul><li>符号引用替换为直接引用</li><li>符号引用: 字符串引用对象不一定被加载</li><li>直接引用: 指针或者地址偏移量, 引用对象一定在内存</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>执行类构造器clinit</li></ul><ol><li>static变量 赋值语句</li><li>static{}语句</li></ol><ul><li>子类的clinit调用前保证父类的clinit被调用</li><li>clinit是线程安全的</li></ul><h3 id="什么是类装载器ClassLoader"><a href="#什么是类装载器ClassLoader" class="headerlink" title="什么是类装载器ClassLoader"></a>什么是类装载器ClassLoader</h3><ul><li>ClassLoader是一个抽象类</li><li>ClassLoader的实例将读入Java字节码将类装载到JVM中</li><li>ClassLoader可以定制,满足不同的字节码流获取方式</li><li>ClassLoader负责类装在过程中的加载阶段</li></ul><h4 id="ClassLoader的重要方法"><a href="#ClassLoader的重要方法" class="headerlink" title="ClassLoader的重要方法"></a>ClassLoader的重要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//载入并返回一个Class</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类,不公开调用</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line"></span><br><span class="line"><span class="comment">//loadClass回调该方法,自定义ClassLoader的推荐方法</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找已经加载的类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></table></figure><h3 id="JDK中的ClassLoader默认设计模式"><a href="#JDK中的ClassLoader默认设计模式" class="headerlink" title="JDK中的ClassLoader默认设计模式"></a>JDK中的ClassLoader默认设计模式</h3><h4 id="ClassLoader分类"><a href="#ClassLoader分类" class="headerlink" title="ClassLoader分类"></a>ClassLoader分类</h4><ul><li>BootStrap ClassLoader(启动ClassLoader)</li><li>Extension ClassLoader(扩展ClassLoader)</li><li>App ClassLoader(应用ClassLoader&#x2F;系统ClassLoader)</li><li>Custom ClassLoader(自定义ClassLoader)</li><li>每个ClassLoader都有一个Parent作为父亲</li></ul><h4 id="ClassLoader的协同工作"><a href="#ClassLoader的协同工作" class="headerlink" title="ClassLoader的协同工作"></a>ClassLoader的协同工作</h4><ol><li>从Custom -&gt; BootStrap 的顺序检查类是否已经加载</li><li>从BootStrap -&gt; Custom 尝试加载类</li><li>BootStrap默认加载rt.jar中的类, 我们可以使用 -Xbootclasspath指定加载类的外部路径</li><li>Extension默认加载 %JAVA_HOME%&#x2F;lib&#x2F;ext&#x2F;*.jar</li><li>App 默认加载Classpath下的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 -Xbootclasspath条件下, 强制加载某个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> FindClassOrder2.class.getClassLoaer();</span><br><span class="line">    <span class="type">byte</span>[] bHelloLoaer = loadClassBytes(<span class="string">&quot;geym.jvm.ch6.findorder.HelloLoader&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">md_defineClass</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    md_defineClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    md_defineClass.invoke(cl, bHelloLoader, <span class="number">0</span>, bHelloLoader.length);</span><br><span class="line">    md_defineClass.setAccessible(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">HelloLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloLoader</span>();</span><br><span class="line">    System.out.println(loader.getClass().getClassLoader());</span><br><span class="line">    loader.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>双亲模式的问题: 顶层ClassLoader, 无法加载底层ClassLoader的类</li><li>javax.xml.parser包中定义了xml解析类的接口Service Provider Interface SPI位于rt.jar. 接口在ClassLoader中. SPI实现类,在AppLoader</li></ul><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>Thread.setContextClassLoader()</p><ul><li>上下文加载器</li><li>是一个”角色”</li><li>用以解决顶层ClassLoader无法访问底层ClassLoader的问题</li><li>基本思想是,在顶层ClassLoader中,传入底层ClassLoader的实例</li></ul><h4 id="双亲模式的破坏"><a href="#双亲模式的破坏" class="headerlink" title="双亲模式的破坏"></a>双亲模式的破坏</h4><ul><li>双清模式是默认的模式,但是不是必须这么做</li><li>Tomcat的WebappClassLoader就会先加载自己的Class, 找不到在委托parent</li><li>OSGi的ClassLoader形成网状结构,根据需要自由加载Class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderClassLoader的实现. 破坏双亲模式,先从底层ClassLoader加载</span></span><br><span class="line"><span class="keyword">protected</span> synchronize Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//First, check if the class has already been loaded</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">re</span> <span class="operator">=</span> findClass(name);</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无法载入类:&quot;</span> + name + <span class="string">&quot;需要请求父加载器&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name, resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(className);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span>==clazz)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> getClassFile(className);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classFile);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fileC</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOuntputStream</span>();</span><br><span class="line">            <span class="type">WritableByteChannel</span> <span class="variable">outC</span> <span class="operator">=</span> Channels.newChannel(baos);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateirect(<span class="number">1024</span>);</span><br><span class="line">            ...</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">            clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h3><ul><li>含义: 当一个class被替换后, 系统无需重启, 替换的类立即生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CVersionA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;hello world! (version A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;class装载验证流程&quot;&gt;&lt;a href=&quot;#class装载验证流程&quot; class=&quot;headerlink&quot; title=&quot;class装载验证流程&quot;&gt;&lt;/a&gt;class装载验证流程&lt;/h3&gt;&lt;h4 id=&quot;加载&quot;&gt;&lt;a href=&quot;#加载&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
    <category term="类装载器" scheme="https://vincent--li.github.io/tags/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java GC参数</title>
    <link href="https://vincent--li.github.io/2019/07/09/Java%20GC%E5%8F%82%E6%95%B0/"/>
    <id>https://vincent--li.github.io/2019/07/09/Java%20GC%E5%8F%82%E6%95%B0/</id>
    <published>2019-07-09T13:38:20.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆回顾"><a href="#堆回顾" class="headerlink" title="堆回顾"></a>堆回顾</h3><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><ul><li>最古老, 最稳定</li><li>效率高</li><li>可能会产生较长的停顿</li><li>-XX:+UseSerialGC</li></ul><ol><li>新生代,老年代使用串行回收</li><li>新生代复制算法</li><li>老年代标记-压缩</li></ol><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><ul><li>ParNew</li></ul><ol><li>-XX:+UseParNewGC 新生代并行,老年代串行</li><li>Serial收集器新生代的并行版本</li><li>复制算法</li><li>多线程,需要多核支持</li><li>-XX:ParallelGCThreads 限制线程数量</li></ol><ul><li>Parallel收集器</li></ul><ol><li>类似ParNew</li><li>新生代复制算法</li><li>老年代 标记-压缩</li><li>更加关注吞吐量</li><li>-XX:+UseParallelGC 使用Parallel收集器+老年代串行</li><li>-XX:+UseParallelOldGC 使用Parallel收集器+并行老年代</li></ol><ul><li>-XX:MaxGCPauseMills 最大停顿时间, 单位毫秒 尽力保证回收时间不超过设定值</li><li>-XX:GCTimeRatio 0-100取值范围, 垃圾收集时间占总时间的比,默认99即最大允许1%时间做GC</li><li>以上两个指标是矛盾的, 不能对停顿时间和吞吐量同时长调优</li></ul><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul><li>Concurrent Mark Sweep 并发标记清除</li><li>标记-清除算法</li><li>与标记-压缩相比</li><li>并发阶段会降低吞吐量</li><li>老年代收集器(新生代使用ParNew)</li><li>-XX:+UseConcMarkSweepGC</li><li>CMS运行过程复杂, 着重实现了标记的过程, 可分为</li></ul><ol><li>初始标记 根可以直接关联到对象, 速度快</li><li>并发标记(和用户线程一起) 主要标记过程,标记全部对象</li><li>重新标记 由于并发标记时,用户线程依然运行, 在正式清理之前,再做修正</li><li>并发清除(和用户线程一起) 基于标记结果,直接清理对象</li></ol><ul><li>特点</li></ul><ol><li>尽可能降低停顿</li><li>会影响系统整体吞吐量和性能</li><li>清理不彻底</li><li>因为和用户线程一起执行,不能在空间快满时再清理</li></ol><ul><li>-XX:CMSInitiatingOccupancyFraction 设置触发GC的阈值</li></ul><ol start="5"><li>使用串行收集器作为后备</li></ol><ul><li>有关碎片</li></ul><ol><li>标记-清除 会产生碎片</li><li>标记-压缩</li></ol><ul><li>-XX:+UseCMSCompactAtFullCollection Full GC后,进行一次整理 整理过程是独占的,会引起停顿时间变长</li><li>-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后,进行一次碎片整理</li><li>-XX:ParallelCMSThreads 设置CMS的线程数量</li><li>减轻GC压力</li></ul><ol><li>软件架构设计</li><li>代码如何写</li><li>堆空间的分配</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;堆回顾&quot;&gt;&lt;a href=&quot;#堆回顾&quot; class=&quot;headerlink&quot; title=&quot;堆回顾&quot;&gt;&lt;/a&gt;堆回顾&lt;/h3&gt;&lt;h3 id=&quot;串行收集器&quot;&gt;&lt;a href=&quot;#串行收集器&quot; class=&quot;headerlink&quot; title=&quot;串行收集器&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
    <category term="GC" scheme="https://vincent--li.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java GC算法与种类</title>
    <link href="https://vincent--li.github.io/2019/07/09/Java%20GC%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A7%8D%E7%B1%BB/"/>
    <id>https://vincent--li.github.io/2019/07/09/Java%20GC%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A7%8D%E7%B1%BB/</id>
    <published>2019-07-09T11:58:30.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GC的概念"><a href="#GC的概念" class="headerlink" title="GC的概念"></a>GC的概念</h3><ul><li>java中,GC的对象是堆空间和永久区</li></ul><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><h4 id="引用计数法-没有被java采用"><a href="#引用计数法-没有被java采用" class="headerlink" title="引用计数法 没有被java采用"></a>引用计数法 没有被java采用</h4><p>通过引用计数来回收垃圾, 但是有问题:</p><ul><li>引用和去引用伴随加法和减法,影响性能</li><li>很难处理循环引用的问题</li></ul><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>现代垃圾回收算法的思想基础. 将垃圾回收分为两个阶段:</p><ul><li>标记阶段<br>在标记阶段,首先通过根节点, 标记所有从根节点开始的可达对象. 因此,未被标记的对象就是未被引用的垃圾对象</li><li>清除阶段<br>清除所有未被标记的对象</li></ul><h4 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h4><p>适用于存活对象比较多的场合. 在标记-清除算法的基础上做了一些优化. 首先要从根节点开始,对所有可达对象做一次标记. 但之后不是简单的清理未标记的对象,而是将所有的存活对象压缩到内存的一端. 之后清理边界外所有空间</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ul><li>与标记-清除算法相比, 复制算法是一种相对高效的回收算法</li><li>不适用于存活对象较多的长河, 如老年代</li><li>将原有的内存空间分为两块. 每次只使用其中一块, 在垃圾回收时, 将正在使用的内存中的存活对象复制到未使用额内存块中, 之后, 清除正在使用的内存块中的所有对象, 交换两个内存的角色, 完成垃圾回收</li><li>最大的问题是: 空间浪费, 整合标记清理思想</li></ul><h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><ul><li>根据对象的存活周期进行分类, 短命对象归为新生代, 长命对象归为老年代</li><li>根据不同代的特点, 选取合适的回收算法</li></ul><ol><li>少量对象存活,适合复制算法</li><li>大量对象存活,适合标记清理或者标记压缩</li></ol><h3 id="可触及性"><a href="#可触及性" class="headerlink" title="可触及性"></a>可触及性</h3><p>所的算法, 需要能够识别一个垃圾对象, 因此需要给出一个可触及性的定义</p><ul><li><p>可触及的: 从根节点可以触及到这个对象</p></li><li><p>可复活的: 一旦所有引用被释放,就是可复活状态, 因为在finalize()中可能复活该对象</p></li><li><p>不可触及的: 在finalize()后,可能会进入不可触及状态, 不可触及的对象不可能复活, 可以回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">finalize方法只会被调用一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;CanReliveObj finize called&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am CanReliveObj&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">CarReliveObj</span>();</span><br><span class="line">    obj = <span class="literal">null</span>; <span class="comment">//可复活</span></span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;obj is null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;obj is no null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;第二次GC&quot;</span>);</span><br><span class="line">    obj = <span class="literal">null</span>; <span class="comment">//不可复活</span></span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;obj is null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;obj is no null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>经验: 避免使用finalize(), 操作不慎可能导致错误</p></li><li><p>优先级低, 何时被调用, 不确定. 因为GC不确定</p></li><li><p>使用try-catch-finally替代它</p></li><li><p>根:</p></li></ul><ol><li>栈中引用的对象</li><li>方法区中静态成员或者常量引用的对象(全局对象)</li><li>JNI方法栈中引用对象</li></ol><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop-The-World"></a>Stop-The-World</h3><ul><li>JAVA中一种全局暂停的现象</li><li>全局停顿, 所有Java代码停止, native代码可以执行, 但不能和JVM交互</li><li>多半由GC引起(其它的情况如下)</li></ul><ol><li>dump线程</li><li>死锁检查</li><li>堆dump</li></ol><ul><li>危害</li></ul><ol><li>长时间服务停止,没有响应</li><li>遇到HA系统,可能引起主备切换,严重危害生产环境</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GC的概念&quot;&gt;&lt;a href=&quot;#GC的概念&quot; class=&quot;headerlink&quot; title=&quot;GC的概念&quot;&gt;&lt;/a&gt;GC的概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;java中,GC的对象是堆空间和永久区&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GC算法&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
    <category term="GC" scheme="https://vincent--li.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM常用运行参数</title>
    <link href="https://vincent--li.github.io/2019/07/08/JVM%E5%B8%B8%E7%94%A8%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <id>https://vincent--li.github.io/2019/07/08/JVM%E5%B8%B8%E7%94%A8%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0/</id>
    <published>2019-07-08T12:23:02.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Trace跟踪参数"><a href="#Trace跟踪参数" class="headerlink" title="Trace跟踪参数"></a>Trace跟踪参数</h3><ul><li>-verbose:gc</li><li>-XX:+PrintGC</li><li>可以打印GC的简要信息</li><li>-XX:+PrintGCDetails 打印GC详细信息</li><li>-XX:+PrintGCTimeStamps 打印GC发生的时间戳</li><li>-Xloggc:log&#x2F;gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题</li><li>-XX:+PrintHeapAtGC 每一次GC后,都打印堆信息</li><li>-XX:+TraceClassLoading 监控类的加载</li><li>-XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型</li></ul><h3 id="堆的分配参数"><a href="#堆的分配参数" class="headerlink" title="堆的分配参数"></a>堆的分配参数</h3><ul><li>-Xmx 最大堆</li><li>-Xms 最小堆</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;Xmx=&quot;</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().maxMemory()/<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;free mem=&quot;</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().freeMemory()/<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;total mem=&quot;</span>);</span><br><span class="line">System.out.println(Runtime.getRuntime().totalMemory()/<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>-Xmn 设置新生代大小,是一个绝对值</li><li>-XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代&#x3D;1:4, 即年轻代占堆的1&#x2F;5</li><li>-XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden &#x3D; 2:8, 即一个Survivor占年轻代的1&#x2F;10</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC</span></span><br><span class="line"><span class="comment">-Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代</span></span><br><span class="line"><span class="comment">-Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用</span></span><br><span class="line"><span class="comment">-Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保</span></span><br><span class="line"><span class="comment">-Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大</span></span><br><span class="line"><span class="comment">-Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] b= <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>-XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件</li><li>-XX:+HeapDumpPath 导出OOM的路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">    v.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>-XX:OnOutOfMemoryError 在OOM的时候, 执行一个脚本.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstatck.bat %p # 打印线程信息, 这个脚本可以是发送邮件甚至是重启程序</span><br></pre></td></tr></table></figure>官方推荐新生代占堆的3&#x2F;8, 幸存代占新生代的1&#x2F;10. OOM时,记得Dump出堆, 确保可以排查现场问题</li></ul><h3 id="永久区分配参数"><a href="#永久区分配参数" class="headerlink" title="永久区分配参数"></a>永久区分配参数</h3><ul><li>-XX:PermSize -XX:MaxPermSize 设置永久区的初始控件大小和最大空间大小. 他们表示一个系统可以容纳多少个类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用CGLIB等库的时候,可能会产生大量的类. 这些类有可能承包永久区导致OOM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">    <span class="type">CglibBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibBean</span>(<span class="string">&quot;geym.jvm.ch3.perm.bean&quot;</span>+ i, <span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上表示: 堆空间实际占用非常少, 但是永久区溢出,一样会出现OOM的情况</li></ul><h3 id="栈的分配参数"><a href="#栈的分配参数" class="headerlink" title="栈的分配参数"></a>栈的分配参数</h3><ul><li>-Xss</li></ul><ol><li>通常只有几百k</li><li>决定了函数的深度</li><li>每个线程有独立的栈空间</li><li>局部变量,参数分配在栈上</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Trace跟踪参数&quot;&gt;&lt;a href=&quot;#Trace跟踪参数&quot; class=&quot;headerlink&quot; title=&quot;Trace跟踪参数&quot;&gt;&lt;/a&gt;Trace跟踪参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;-verbose:gc&lt;/li&gt;
&lt;li&gt;-XX:+PrintGC&lt;/l</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
    <category term="参数调优" scheme="https://vincent--li.github.io/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行机制</title>
    <link href="https://vincent--li.github.io/2019/07/08/JVM/"/>
    <id>https://vincent--li.github.io/2019/07/08/JVM/</id>
    <published>2019-07-08T01:10:50.000Z</published>
    <updated>2022-09-16T16:12:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM运行机制"><a href="#JVM运行机制" class="headerlink" title="JVM运行机制"></a>JVM运行机制</h3><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><ul><li>每个线程拥有一个PC寄存器</li><li>在线程创建时创建</li><li>总是指向下一条指令的地址</li><li>执行本地方法时, PC的值为undefined</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>保存装载的类信息<ul><li>类型的常量池</li><li>字段, 方法信息</li><li>方法字节码</li></ul></li><li>通常和永久区关联在一起</li></ul><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><ul><li>和程序开发密切相关</li><li>应用系统对象都保存在java堆中</li><li>所有线程共享java堆</li><li>对分代GC来说, 堆也是分代</li><li>GC的主要工作区间: eden|s0|s1|tenured</li></ul><h4 id="java栈"><a href="#java栈" class="headerlink" title="java栈"></a>java栈</h4><ul><li>线程私有</li><li>栈由一系列帧组成(因此java栈也叫做栈帧)</li><li>帧保存一个方法的局部变量,操作数栈,常量池指针</li><li>每一次方法调用创建一个帧,并压栈</li></ul><h4 id="java栈之局部变量表-包含参数和局部变量"><a href="#java栈之局部变量表-包含参数和局部变量" class="headerlink" title="java栈之局部变量表(包含参数和局部变量)"></a>java栈之局部变量表(包含参数和局部变量)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackDemo</span> &#123;</span><br><span class="line">  <span class="comment">/* 假设局部变量表里是一个槽位, 每个槽位最大容纳32位的数据*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 静态方法的局部变量表为:</span></span><br><span class="line"><span class="comment">       0 int int i</span></span><br><span class="line"><span class="comment">       1 long long l</span></span><br><span class="line"><span class="comment">       2 float float f</span></span><br><span class="line"><span class="comment">       3 reference Object o</span></span><br><span class="line"><span class="comment">       4 int byte b</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> run <span class="title function_">Static</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> l, <span class="type">float</span> f, Object o, <span class="type">byte</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例方法的局部变量表为:</span></span><br><span class="line"><span class="comment">       0 reference this 当前对象的引用</span></span><br><span class="line"><span class="comment">       1 int char c</span></span><br><span class="line"><span class="comment">       2 int short s</span></span><br><span class="line"><span class="comment">       3 int boolean bµ</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">runInstance</span><span class="params">(<span class="type">char</span> c, <span class="type">short</span> s, <span class="type">boolean</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java栈之函数调用组成帧栈-包括操作数栈和返回地址"><a href="#java栈之函数调用组成帧栈-包括操作数栈和返回地址" class="headerlink" title="java栈之函数调用组成帧栈(包括操作数栈和返回地址)"></a>java栈之函数调用组成帧栈(包括操作数栈和返回地址)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数调用过程, 会压栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStatic</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> l, <span class="type">float</span> f, Object o, <span class="type">byte</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> runStatic(i, l, f, o, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java栈之操作数栈"><a href="#java栈之操作数栈" class="headerlink" title="java栈之操作数栈"></a>java栈之操作数栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  java没有寄存器, 所有参数传递使用操作数栈</span></span><br><span class="line"><span class="comment">  以下方法的操作数栈情况:</span></span><br><span class="line"><span class="comment">  0 iconst_0 0压栈</span></span><br><span class="line"><span class="comment">  1 istore_2 弹出int,存放于局部变量2</span></span><br><span class="line"><span class="comment">  2 iload_0 把局部变量0压栈</span></span><br><span class="line"><span class="comment">  3 iload_1 把局部变量1压栈</span></span><br><span class="line"><span class="comment">  4 iadd 弹出2个变量,求和,结果压栈</span></span><br><span class="line"><span class="comment">  5 istore_2 弹出结果,放于局部变量2</span></span><br><span class="line"><span class="comment">  6 iload_2 局部变量2压栈</span></span><br><span class="line"><span class="comment">  7 ireturn 返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java栈之栈上分配"><a href="#java栈之栈上分配" class="headerlink" title="java栈之栈上分配"></a>java栈之栈上分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BcmBasicString</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆上分配, 每次要手动清理内存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">  BcmBasicString* str = <span class="keyword">new</span> <span class="title class_">BcmBasicString</span>;</span><br><span class="line">  ...</span><br><span class="line">  delete str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈上分配, 不会出现内存泄漏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">  BcmBasicString str;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈上分配特点</p><ul><li>小对象(一般几十个bytes), 在没有逃逸的情况下, 可以直接分配在栈上</li><li>直接分配在栈上, 可以自动回收, 减轻GC压力</li><li>大对象或者逃逸对象(即会被共享的对象)无法栈上分配</li></ul><h4 id="堆-栈-方法区交互"><a href="#堆-栈-方法区交互" class="headerlink" title="堆, 栈, 方法区交互"></a>堆, 栈, 方法区交互</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppMain</span>&#123;</span><br><span class="line">  <span class="comment">//运行时, jvm把appmain的信息都放入方法区</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//test1是引用, 放到栈区, Sample是自定义对象, 放到堆里面</span></span><br><span class="line">    <span class="type">Sample</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    <span class="type">Sample</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    test1.printName();</span><br><span class="line">    test2.printName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">  <span class="comment">//运行时, jvm把sample的信息都放入方法区</span></span><br><span class="line">  <span class="comment">// new Sample实例后, name引用放到栈区里, name对象放到堆里</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sample</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print 方法本身放入方法区里</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><ul><li>每一个线程有一个工作从内存和主存独立</li><li>工作内存存放主存中变量值的拷贝</li><li>当数据从”主内存”复制到”线程工作内存”时, 必须出现两个动作:</li></ul><ol><li>主内存执行的(read)操作</li><li>工作内存执行相应的load操作</li></ol><ul><li>当数据从”线程工作内存”拷贝到”主内存”时, 也出现两个动作:</li></ul><ol><li>工作内存执行store操作</li><li>主内存执行相应的写write操作</li></ol><ul><li>每个操作都是原子的, 即执行期间不会被中断</li><li>对于普通变量, 一个线程中更新的值,不能马上反应在其他变量中. 如果需要在其他线程中立即课件, 需要使用volatile关键字</li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  volatile 不能替代锁, 一般认为volatile比锁性能好(不绝对)</span></span><br><span class="line"><span class="comment">  选择使用volatile的条件是: 语义是否满足应用, 它是线程不安全的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileStopThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopMe</span><span class="params">()</span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Stop thread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">VolatileStopThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileStopThread</span>();</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    t.stopMe();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul><li>一个线程修改了变量, 其他线程可以立即知道</li></ul><h4 id="保证可见性的方法"><a href="#保证可见性的方法" class="headerlink" title="保证可见性的方法"></a>保证可见性的方法</h4><ul><li>volatile</li><li>synchronized(unlock之前, 写变量值回主存)</li><li>final(一旦初始化完成,其它线程就可见)</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul><li>在本线程内,操作都是有序的</li><li>在线程外观察,操作都是无序的(指令重排 或 主内存同步延时)</li></ul><h4 id="指令重排的基本原则"><a href="#指令重排的基本原则" class="headerlink" title="指令重排的基本原则"></a>指令重排的基本原则</h4><ul><li>程序顺序原则: 一个线程内保证语义的串行性</li><li>volatile规则: volatile变量的写, 先发生于读</li><li>锁规则: 解锁(unlock)必然发生在随后的加锁(lock)前</li><li>传递性: A先于B, B先于C 那么A必然先于C</li><li>线程的start方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结(Thread.join())</li><li>线程的中断(interrupte())先于被中断线程的代码</li><li>对象的构造函数执行先于finalize()方法</li></ul><h4 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h4><ul><li>解释执行以解释方式运行字节码</li><li>解释执行的意思是: 读一句执行一句</li></ul><h4 id="编译运行-JIT"><a href="#编译运行-JIT" class="headerlink" title="编译运行(JIT)"></a>编译运行(JIT)</h4><ul><li>将字节码编译成机器码</li><li>直接执行机器码</li><li>运行时编译</li><li>编译后性能有数量级的提升</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JVM运行机制&quot;&gt;&lt;a href=&quot;#JVM运行机制&quot; class=&quot;headerlink&quot; title=&quot;JVM运行机制&quot;&gt;&lt;/a&gt;JVM运行机制&lt;/h3&gt;&lt;h4 id=&quot;PC寄存器&quot;&gt;&lt;a href=&quot;#PC寄存器&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="Java" scheme="https://vincent--li.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://vincent--li.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-视频学习系列15-隐马尔可夫模型</title>
    <link href="https://vincent--li.github.io/2019/06/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9715-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    <id>https://vincent--li.github.io/2019/06/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9715-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-06-08T09:34:36.000Z</published>
    <updated>2022-09-16T16:12:29.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h3><pre class="mermaid">graph LRx1(x1)-->x2(x2)x2-->x3(x3)x3-->xn(xn)x1-->y1(y1)x2-->y2(y2)x3-->y3(y3)</pre><h3 id="模型公式"><a href="#模型公式" class="headerlink" title="模型公式"></a>模型公式</h3><p>目标: 求$P(x_t|y_{1:t})$<br>步骤: </p><ol><li><p>predict 求$P(x_t|y_{1:t-1})$<br>使用到恒等变形公式:<br>$P(A|BC)$<br>$&#x3D; \frac{P(ABC)}{P(BC)}$<br>$&#x3D; \frac{P(B|AC)P(A|C)P(C)}{P(B|C)P(C)}$<br>$&#x3D; \frac{P(B|AC)P(A|C)}{P(B|C)}$</p></li><li><p>update 求$P(x_t|y_{1:t})$<br>依旧使用上面的恒等变形公式:<br>$P(x_t|y_{1:t}) &#x3D; P(x_t|y_t,y_{t-1})$<br>$&#x3D;$</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题模型&quot;&gt;&lt;a href=&quot;#问题模型&quot; class=&quot;headerlink&quot; title=&quot;问题模型&quot;&gt;&lt;/a&gt;问题模型&lt;/h3&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
x1(x1)--&gt;x2(x2)
x2--&gt;x3(x3)
x3--&gt;xn</summary>
      
    
    
    
    <category term="机器学习" scheme="https://vincent--li.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://vincent--li.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="隐马尔可夫" scheme="https://vincent--li.github.io/tags/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-视频学习系列14-贝叶斯网络</title>
    <link href="https://vincent--li.github.io/2019/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9714-%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/"/>
    <id>https://vincent--li.github.io/2019/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9714-%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/</id>
    <published>2019-06-07T15:33:54.000Z</published>
    <updated>2022-09-16T16:12:29.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="机器学习的四种paradigms"><a href="#机器学习的四种paradigms" class="headerlink" title="机器学习的四种paradigms"></a>机器学习的四种paradigms</h3><ol><li>连接主义(connectionist) aka 深度学习,神经网络. 认为表示学习非常重要. 需要学出来一个分布式的表示(distributed  representation). Tensorflow PyTorch Theano Caffe</li><li>符号主义 Prolog 基于逻辑的学习</li><li>统计学习 基于统计学的基本假设 SVM, 统计学习理论, vc-dimention</li><li>概率图模型 GAN VAE</li></ol><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>$P(A|B)&#x3D;\frac{P(B|A) * P(A)}{P(B)}$</p><h3 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h3><p>以高效的方法求变量的联合分布</p><pre class="mermaid">graph TD  Earthquake(Earthquake)-->Radio(Radio)  Earthquake-->Alarm(Alarm)  Burglary(Burglary)-->Alarm  Alarm-->Call(Call)</pre><ol><li><p>DAG(Directed Acyclic Graph) 有向无环图<br>Node-随机变量, Edges-边</p></li><li><p>上帝视角的P(B,E,A,R,C)<br>$X_i$和$X_{ancestors}|X_{parents}$独立<br>$P(B,E,A,R,C)$<br>$&#x3D;P(B)P(E|B)P(A|B,E)P(R|A,B,E)P(C|R,A,B,E)$<br>$&#x3D;P(B)P(E)P(A|B,E)P(R|E)P(C|A)$</p></li><li><p>DAG能够告诉我们<br>如果我们有n个变量$x_i$,那么这些变的联合概率分布可以拆解为:<br>$P(X_{1:n})&#x3D;P(x_1,x_2,\cdots,x_n)&#x3D;\prod_{i&#x3D;1}^nP(x_i|parents(x_i))$</p></li></ol><h3 id="概率图模型求法"><a href="#概率图模型求法" class="headerlink" title="概率图模型求法"></a>概率图模型求法</h3><p>概率图模型的求法: 消元法 aka(动态规划) aka(分配律)<br>动态规划的思想在: 概率图模型, HMM, VC-dimension, RL中的MDP, 神经网络BP中的DP 这几块用过</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;机器学习的四种paradigms&quot;&gt;&lt;a href=&quot;#机器学习的四种paradigms&quot; class=&quot;headerlink&quot; title=&quot;机器学习的四种paradigms&quot;&gt;&lt;/a&gt;机器学习的四种paradigms&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;连接主义(con</summary>
      
    
    
    
    <category term="机器学习" scheme="https://vincent--li.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://vincent--li.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="贝叶斯网络" scheme="https://vincent--li.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-视频学习系列12-聚类</title>
    <link href="https://vincent--li.github.io/2019/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9712-%E8%81%9A%E7%B1%BB/"/>
    <id>https://vincent--li.github.io/2019/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9712-%E8%81%9A%E7%B1%BB/</id>
    <published>2019-06-07T08:02:35.000Z</published>
    <updated>2022-09-16T16:12:29.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><h3 id="基于对象的聚类-Objective-based-clustering"><a href="#基于对象的聚类-Objective-based-clustering" class="headerlink" title="基于对象的聚类(Objective based clustering)"></a>基于对象的聚类(Objective based clustering)</h3><h4 id="K-means-聚类"><a href="#K-means-聚类" class="headerlink" title="K-means 聚类"></a>K-means 聚类</h4><ul><li>k-means 问题描述: 找到cpt1,cpt2,….cpt, 使 $ min\sum_{i&#x3D;1}^n m_{j \in 1 \cdots k} d^2(x^i,c_j) $</li><li>k-median 问题描述: 找到cpt1,cpt2,….cpt, 使 $ min\sum_{i&#x3D;1}^n m_{j \in 1 \cdots k} d(x^i,c_j) $</li><li>k-center 问题描述: 找到一个分类方式最小化最大半径</li></ul><h4 id="Lloyds-method-总是收敛的-目标函数单调递减-并且有下界-该方法一定收敛"><a href="#Lloyds-method-总是收敛的-目标函数单调递减-并且有下界-该方法一定收敛" class="headerlink" title="Lloyds method: 总是收敛的(目标函数单调递减,并且有下界, 该方法一定收敛)"></a>Lloyds method: 总是收敛的(目标函数单调递减,并且有下界, 该方法一定收敛)</h4><p>问题描述:</p><blockquote><p>Input: 一组数据集 $ x^1, x^2, \cdots, x^n \in R^d$<br>Initialize:<br>    1. 中心点 $c_1, c_2, \cdots, c_k \in R^d$<br>    2. 簇$C_1,C_2,\cdots,C_k$以随机方式聚合<br>Repeat:直到目标函数没有任何变化<br>    1. for each j: $C_j \in {x \in S }$ where closest center is $c_j$<br>    2. for each j: $c_j \in avg(c_j)$</p></blockquote><ul><li>初始化很重要(决定了收敛的快慢和输出的质量), 常用的有三种:</li></ul><ol><li>随机挑选中心化点. performance 比较差. 随着k的增大, 效果指数级下降<br>对于k个高斯分布来说, 每个初始化的中心正好在一个不同的高斯分布的概率$\approx\frac {k!}{k^k}\approx\frac1{e^k}$</li><li>最远遍历(Furthest Point Heuristic)<br>先固定一个$c_j$,然后在后续每次取中心点的时候, 都评估距离已经选出来的点最远的点作为当前的中心点. 以此类推, 选出k个中心点. 解决了高斯分布的问题, 但是可能对噪声(outlier)特别敏感</li><li>K-means++ (效果好, 效率快): 基本思路$D^{\alpha}$抽样<br>理论上 K-means++ 会得到O(logk)的最优解.<br>如果$\alpha$&#x3D;0, 就是随机抽样<br>如果$\alpha$&#x3D;$\infin$, 就是最远点初始化<br>如果$\alpha$&#x3D;2, k-means++</li></ol><ul><li><p>K-means++&#x2F;Lloyd’s 运行的时间复杂度<br>K-means++ 初始化: O(nkd) ,其中n是样本点个数,k是聚类个数, d是样本维度</p></li><li><p>如何选择k</p></li></ul><ol><li>交叉验证</li><li>Elbow’s method. 找到不同k之间的损失函数下降最快的地方. </li><li>尝试层次聚类</li></ol><h3 id="层次聚类-Hierarchical-clustering"><a href="#层次聚类-Hierarchical-clustering" class="headerlink" title="层次聚类(Hierarchical clustering)"></a>层次聚类(Hierarchical clustering)</h3><p>主要讲由下至上的层次聚类<br>1:34:16 to be continue</p><h3 id="K-means-代码分析及实现"><a href="#K-means-代码分析及实现" class="headerlink" title="K-means 代码分析及实现"></a>K-means 代码分析及实现</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;聚类&quot;&gt;&lt;a href=&quot;#聚类&quot; class=&quot;headerlink&quot; title=&quot;聚类&quot;&gt;&lt;/a&gt;聚类&lt;/h2&gt;&lt;h3 id=&quot;基于对象的聚类-Objective-based-clustering&quot;&gt;&lt;a href=&quot;#基于对象的聚类-Objective-b</summary>
      
    
    
    
    <category term="机器学习" scheme="https://vincent--li.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://vincent--li.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="聚类" scheme="https://vincent--li.github.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
    <category term="视频" scheme="https://vincent--li.github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>markdown复习</title>
    <link href="https://vincent--li.github.io/2019/06/06/markdown%E5%A4%8D%E4%B9%A0/"/>
    <id>https://vincent--li.github.io/2019/06/06/markdown%E5%A4%8D%E4%B9%A0/</id>
    <published>2019-06-06T02:37:15.000Z</published>
    <updated>2022-09-16T16:12:29.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown支持6中级别的标题, 对应HTML标签h1-h6</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># h1</span></span><br><span class="line"><span class="section">## h2</span></span><br><span class="line"><span class="section">### h3</span></span><br><span class="line"><span class="section">#### h4</span></span><br><span class="line"><span class="section">##### h5</span></span><br><span class="line"><span class="section">###### h6</span></span><br></pre></td></tr></table></figure><p>此外, markdown还支持简单的两级标题设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">这是一级标题</span></span><br><span class="line"><span class="section">===</span></span><br><span class="line"><span class="section">这是二级标题</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="段落及区块引用"><a href="#段落及区块引用" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这段文字将被高亮显示</span></span><br></pre></td></tr></table></figure><blockquote><p>这段文字将被高亮显示</p></blockquote><h3 id="插入链接或图片"><a href="#插入链接或图片" class="headerlink" title="插入链接或图片"></a>插入链接或图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">点击跳转至百度</span>](<span class="link">http://www.baidu.com</span>)</span><br><span class="line">![<span class="string">图片</span>](<span class="link">https://upload.jianshu.io/users/upload_avatars/2130822/3507378e03a8.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/120/h/120</span>)</span><br><span class="line">自动生成连接 <span class="language-xml">&lt;https://www.baidu.com&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://www.baidu.com/">点击跳转至百度</a><br><img src="https://upload.jianshu.io/users/upload_avatars/2130822/3507378e03a8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/1/w/120/h/120" alt="图片"><br>自动生成连接 <a href="https://www.baidu.com/">https://www.baidu.com</a></p><p>注: 引用图片和链接的唯一区别就是最前面的叹号</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown支持有序列表和无序列表两种形式:</p><ul><li>无序列表使用*或+或-标识</li><li>有序列表使用数字加.标识,例如1.</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 黄瓜</span><br><span class="line"><span class="bullet">*</span> 玉米</span><br><span class="line"><span class="bullet">*</span> 茄子</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 黄瓜</span><br><span class="line"><span class="bullet">+</span> 玉米</span><br><span class="line"><span class="bullet">+</span> 茄子</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 黄瓜</span><br><span class="line"><span class="bullet">-</span> 玉米</span><br><span class="line"><span class="bullet">-</span> 茄子</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 黄瓜</span><br><span class="line"><span class="bullet">2.</span> 玉米</span><br><span class="line"><span class="bullet">3.</span> 茄子</span><br></pre></td></tr></table></figure><p>以上标记效果如下</p><ul><li>黄瓜</li><li>玉米</li><li>茄子</li></ul><ol><li>黄瓜</li><li>玉米</li><li>茄子</li></ol><p>注: 对于有序列表, markdown只关注第一个item的数字编号,然后按次序向后递增. 不管后面的序号是否连续,始终以第一个item的数字编号为锚点</p><h3 id="使用列表的注意事项"><a href="#使用列表的注意事项" class="headerlink" title="使用列表的注意事项"></a>使用列表的注意事项</h3><ul><li>如果一个item里面包含了多个段落, *与段落首字母之间需要保留4个空格</li><li>如果列表钟有区块引用, 区块引用标记符也要缩进4个空格</li></ul><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>有时候为了排版漂亮, 需要加入分隔线. markdown使用下面两种形式之一加入分隔线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"><span class="strong">**<span class="emphasis">*</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">---</span></span></span></span><br></pre></td></tr></table></figure><p>效果如下, 分隔线语法比较松. 符号之间有空格也可以识别</p><hr><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>有时候, 需要对文字做强调. 使用如下方式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*这是斜体*</span></span><br><span class="line"><span class="emphasis">_这是斜体_</span></span><br><span class="line"><span class="strong">**这是粗体**</span></span><br><span class="line"><span class="strong">__这是粗体__</span></span><br><span class="line">~~删除~~</span><br></pre></td></tr></table></figure><p><del>删除</del><br><em>这是斜体</em><br><em>这是斜体</em><br><strong>这是粗体</strong><br><strong>这是粗体</strong></p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="mathjax"><a href="#mathjax" class="headerlink" title="mathjax"></a>mathjax</h3><p>参考链接 <a href="https://jingyan.baidu.com/article/4b52d702df537efc5c774bc9.html">https://jingyan.baidu.com/article/4b52d702df537efc5c774bc9.html</a></p><p>如果使用mathjax需要在FrontMatter中写入<code>mathjax: true</code></p><h4 id="公式标记"><a href="#公式标记" class="headerlink" title="公式标记"></a>公式标记</h4><p>有两种方式</p><ul><li>一种是行内标记用$符号表示</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>(W<span class="built_in">_</span>1−W<span class="built_in">_</span>2)x+b<span class="built_in">_</span>1−b<span class="built_in">_</span>2=0<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>这是一个行内公式 $(W_1−W_2)x+b_1−b_2&#x3D;0$</p><ul><li>一种是整行公式用两个$$</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">(W<span class="built_in">_</span>1−W<span class="built_in">_</span>2)x+b<span class="built_in">_</span>1−b<span class="built_in">_</span>2=0</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如下<br>$$<br>(W_1−W_2)x+b_1−b_2&#x3D;0<br>$$</p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><table><thead><tr><th>名称</th><th>大写</th><th>写法</th><th>小写</th><th>写法</th></tr></thead><tbody><tr><td>alpha</td><td>A</td><td>A</td><td>α</td><td>\alpha</td></tr><tr><td>beta</td><td>B</td><td>B</td><td>β</td><td>\beat</td></tr><tr><td>gamma</td><td>Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td></tr><tr><td>delta</td><td>Δ</td><td>\Delta</td><td>δ</td><td>\delta</td></tr><tr><td>epsilon</td><td>E</td><td>E</td><td>ϵ</td><td>\epsilon</td></tr><tr><td>zeta</td><td>Z</td><td>Z</td><td>ζ</td><td>\zeta</td></tr><tr><td>eta</td><td>H</td><td>H</td><td>η</td><td>\eta</td></tr><tr><td>theta</td><td>Θ</td><td>\Theta</td><td>θ</td><td>\theta</td></tr><tr><td>iota</td><td>I</td><td>I</td><td>ι</td><td>\iota</td></tr><tr><td>kappa</td><td>K</td><td>K</td><td>κ</td><td>\kappa</td></tr><tr><td>lambda</td><td>Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td></tr><tr><td>mu</td><td>M</td><td>M</td><td>μ</td><td>\mu</td></tr><tr><td>nu</td><td>N</td><td>N</td><td>ν</td><td>\nu</td></tr><tr><td>xi</td><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td></tr><tr><td>omicron</td><td>O</td><td>O</td><td>ο</td><td>\omicron</td></tr><tr><td>pi</td><td>Π</td><td>\Pi</td><td>π</td><td>\pi</td></tr><tr><td>rho</td><td>P</td><td>P</td><td>ρ</td><td>\rho</td></tr><tr><td>sigma</td><td>Σ</td><td>\Sigma</td><td>σ</td><td>\sigma</td></tr><tr><td>tau</td><td>T</td><td>T</td><td>τ</td><td>\tau</td></tr><tr><td>upsilon</td><td>Υ</td><td>\Upsilon</td><td>υ</td><td>\upsilon</td></tr><tr><td>phi</td><td>Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td></tr><tr><td>chi</td><td>X</td><td>X</td><td>χ</td><td>\chi</td></tr><tr><td>psi</td><td>Ψ</td><td>\Psi</td><td>ψ</td><td>\psi</td></tr><tr><td>omega</td><td>Ω</td><td>\Omega</td><td>ω</td><td>\omega</td></tr></tbody></table><h4 id="上标-x2F-下标"><a href="#上标-x2F-下标" class="headerlink" title="上标&#x2F;下标"></a>上标&#x2F;下标</h4><p>上标和下标分别使用^和_来实现</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>x<span class="built_in">_</span>i<span class="built_in">^</span>2=10<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>log<span class="built_in">_</span>2<span class="built_in">^</span>x=16<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如下<br>$x_i^2&#x3D;10$<br>$log_2^x&#x3D;16$</p><p>上下标默认只读后面一个字符, 如果有多个字符需要用{}包裹</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>10<span class="built_in">^</span>&#123;10&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>10<span class="built_in">^</span>10<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如:<br>$10^{10}$<br>$10^10$</p><p>如果左右两边都要有上下标</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;<span class="built_in">^</span>1<span class="built_in">_</span>2&#125;A&#123;<span class="built_in">^</span>3<span class="built_in">_</span>4&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如${^1_2}A{^3_4}$</p><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><ul><li>小括号与方括号: 使用原始的小括号和方括号即可 $(2+3)[4+4]$</li><li>大括号: 需要使用转义符号\{和\} 如: $\{a<em>b\}$ &#x3D; ${a</em>b}$</li><li>尖括号: 使用\langle和\rangle分别表示左尖括号和右尖括号$\langle x \rangle$  &#x3D;&#x3D; $\langle x \rangle$</li><li>上取整: 使用\lceil和\rceil表示. 如: $\lceil x \rceil$ &#x3D;&#x3D; $\lceil x \rceil$</li><li>下取整: 使用\lfloor和\rfloor表示. 如 $\lfloor x \rfloor$ &#x3D; $\lfloor x \rfloor$</li><li>需要注意原始括号不会根据公式的大小缩放. 可以使用\left(…\right)来缩放. 如: $\left( \frac1{\frac12} \right)$ 和 $(\frac1{\frac12})$</li></ul><h4 id="求和-x2F-积分-x2F-多重积分"><a href="#求和-x2F-积分-x2F-多重积分" class="headerlink" title="求和&#x2F;积分&#x2F;多重积分"></a>求和&#x2F;积分&#x2F;多重积分</h4><ul><li>\sum表示求和, 下标表示求和下限, 上标表示求和上限</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>1<span class="built_in">^</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如: $\sum_1^n$</p><ul><li>\int表示求积分, 下标表示求和下限, 上标表示求和上限</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>1<span class="built_in">^</span><span class="keyword">\infty</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如: $\int_1^\infty$</p><ul><li>\iint表示求积分, 下标表示求和下限, 上标表示求和上限</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\iint</span><span class="built_in">_</span>1<span class="built_in">^</span><span class="keyword">\infty</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如: $\iint_1^\infty$</p><ul><li>类似标签</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>1<span class="built_in">^</span>n<span class="built_in">$</span> == ∏</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\bigcup</span><span class="built_in">$</span> == ⋃</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\bigcap</span><span class="built_in">$</span> == ⋂</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\iint</span><span class="built_in">$</span> == ∬</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\approx</span><span class="built_in">$</span> == ≈</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\times</span><span class="built_in">$</span> == ×</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\partial</span><span class="built_in">$</span> == ∂</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;a&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>1 <span class="keyword">\choose</span> n<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;y&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\overline</span>&#123;y&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\underline</span>&#123;abc&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f(x) = </span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">x + 1 <span class="built_in">&amp;</span> x <span class="keyword">\gt</span> 1 <span class="keyword">\\</span></span><br><span class="line">2x <span class="built_in">&amp;</span> others</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果如:<br>$\prod_1^n$</p><p>$\bigcup$</p><p>$\bigcap$</p><p>$\iint$</p><p>$\approx$</p><p>$\times$</p><p>$\partial$</p><p>$\vec{a}$</p><p>$1 \choose n$</p><p>$\hat{y}$</p><p>$\overline{y}$</p><p>$\underline{abc}$</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>\vdots &amp; \vdots &amp; \vdots \<br>\end{bmatrix}<br>$$</p><p>$$<br>f(x) &#x3D;<br>\begin{cases}<br>x + 1 &amp; x \gt 1 \<br>2x &amp; others<br>\end{cases}<br>$$</p><h4 id="分式-x2F-根式"><a href="#分式-x2F-根式" class="headerlink" title="分式&#x2F;根式"></a>分式&#x2F;根式</h4><p>分式两种方式:</p><ul><li>使用$\frac ab$, 结果为$\frac ab$. 如果分子分母不是单个字符需要用{}</li><li>使用\over来分隔, ${a+1\over b+1}$ &#x3D;&#x3D; ${a+1\over b+1}$</li></ul><p>根式用\$\sqrt[a]b\$表示:<br>其中，方括号内的值用来表示开几次方，省略方括号则表示开方, 如:<br>例一: \$\sqrt[4]{\frac xy}\$ &#x3D;&#x3D; $\sqrt[4]{\frac xy}$<br>例二: \$\sqrt{x^3}\$ &#x3D;&#x3D; $\sqrt{x^3}$</p><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><ul><li>行内代码, 单组反引号</li><li>代码块, 两个以上反引号包裹<br>这是一段<code>var x=3</code>行内代码<br>以下是代码块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fun</span>(<span class="attr">x</span>: <span class="title class_">Int</span>, <span class="attr">y</span>:<span class="title class_">Int</span>): <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表头|条目一|条目二</span><br><span class="line">:---:|:---:|:---:</span><br><span class="line">项目|项目一|项目二</span><br></pre></td></tr></table></figure><p>以上标记显示效果如下:</p><table><thead><tr><th align="center">表头</th><th align="center">条目一</th><th align="center">条目二</th></tr></thead><tbody><tr><td align="center">项目</td><td align="center">项目一</td><td align="center">项目二</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>详见 <a href="https://mermaidjs.github.io/">https://mermaidjs.github.io/</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...mermaid ...请替换成反引号</span><br><span class="line">graph TD</span><br><span class="line">client1--&gt;|read / write|SVN((SVN server))</span><br><span class="line">client2--&gt;|read only|SVN</span><br><span class="line">client3--&gt;|read / write|SVN</span><br><span class="line">client4--&gt;|read only|SVN</span><br><span class="line">client5(...)--&gt;SVN</span><br><span class="line">SVN---|store the data|sharedrive</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如下</p><pre class="mermaid">graph TD;client1-->|read / write|SVN((SVN server));client2-->|read only|SVN;client3-->|read / write|SVN;client4-->|read only|SVN;client5(...)-->SVN;SVN---|store the data|sharedrive;</pre><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...mermaid 将...替换成反引号</span><br><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section A section</span><br><span class="line">        Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        Future task               :         des3, after des2, 5d</span><br><span class="line">        Future task2               :         des4, after des3, 5d</span><br><span class="line">        section Critical tasks</span><br><span class="line">        Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">        Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">        Create tests for parser             :crit, active, 3d</span><br><span class="line">        Future task in critical line        :crit, 5d</span><br><span class="line">        Create tests for renderer           :2d</span><br><span class="line">        Add to mermaid                      :1d</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如下</p><pre class="mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section A section        Completed task            :done,    des1, 2014-01-06,2014-01-08        Active task               :active,  des2, 2014-01-09, 3d        Future task               :         des3, after des2, 5d        Future task2               :         des4, after des3, 5d        section Critical tasks        Completed task in the critical line :crit, done, 2014-01-06,24h        Implement parser and jison          :crit, done, after des1, 2d        Create tests for parser             :crit, active, 3d        Future task in critical line        :crit, 5d        Create tests for renderer           :2d        Add to mermaid                      :1d</pre><h3 id="UML序列图"><a href="#UML序列图" class="headerlink" title="UML序列图"></a>UML序列图</h3><p>语法参考：<a href="https://bramp.github.io/js-sequence-diagrams/">https://bramp.github.io/js-sequence-diagrams/</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure><p>效果如下</p><pre class="mermaid">sequenceDiagram    participant Alice    participant Bob    Alice->John: Hello John, how are you?    loop Healthcheck        John->John: Fight against hypochondria    end    Note right of John: Rational thoughts <br/>prevail...    John-->Alice: Great!    John->Bob: How about you?    Bob-->John: Jolly good!</pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="特殊符号处理"><a href="#特殊符号处理" class="headerlink" title="特殊符号处理"></a>特殊符号处理</h3><p>\反斜杠插入用到的特殊符号,主要用到以下几种特殊符号</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line"><span class="emphasis">_   底线</span></span><br><span class="line"><span class="emphasis">&#123;&#125;  花括号</span></span><br><span class="line"><span class="emphasis">[]  方括号</span></span><br><span class="line"><span class="emphasis">()  括弧</span></span><br><span class="line"><span class="emphasis">#   井字号</span></span><br><span class="line"><span class="emphasis">+   加号</span></span><br><span class="line"><span class="emphasis">-   减号</span></span><br><span class="line"><span class="emphasis">.   英文句点</span></span><br><span class="line"><span class="emphasis">!   惊叹号</span></span><br></pre></td></tr></table></figure><h3 id="给文字上色"><a href="#给文字上色" class="headerlink" title="给文字上色"></a>给文字上色</h3><p>使用html方式给文字上色</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#ff0000&#x27;</span>&gt;</span></span>测试红色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下<br><font color='#ff0000'>测试红色</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h</summary>
      
    
    
    
    
    <category term="markdown" scheme="https://vincent--li.github.io/tags/markdown/"/>
    
    <category term="流程图" scheme="https://vincent--li.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
    <category term="mathjax" scheme="https://vincent--li.github.io/tags/mathjax/"/>
    
  </entry>
  
</feed>
