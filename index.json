[{"categories":null,"content":"基础语法 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:0","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"标题 Markdown支持6中级别的标题, 对应HTML标签h1-h6 # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 此外, markdown还支持简单的两级标题设置 这是一级标题 === 这是二级标题 --- ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:1","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"段落及区块引用 \u003e 这段文字将被高亮显示 这段文字将被高亮显示 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:2","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"插入链接或图片 [点击跳转至百度](http://www.baidu.com) ![图片](https://upload.jianshu.io/users/upload_avatars/2130822/3507378e03a8.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/120/h/120) 自动生成连接 \u003chttps://www.baidu.com\u003e 点击跳转至百度 自动生成连接 https://www.baidu.com 注: 引用图片和链接的唯一区别就是最前面的叹号 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:3","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"列表 Markdown支持有序列表和无序列表两种形式: 无序列表使用*或+或-标识 有序列表使用数字加.标识,例如1. * 黄瓜 * 玉米 * 茄子 + 黄瓜 + 玉米 + 茄子 - 黄瓜 - 玉米 - 茄子 1. 黄瓜 2. 玉米 3. 茄子 以上标记效果如下 黄瓜 玉米 茄子 黄瓜 玉米 茄子 注: 对于有序列表, markdown只关注第一个item的数字编号,然后按次序向后递增. 不管后面的序号是否连续,始终以第一个item的数字编号为锚点 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:4","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"使用列表的注意事项 如果一个item里面包含了多个段落, *与段落首字母之间需要保留4个空格 如果列表钟有区块引用, 区块引用标记符也要缩进4个空格 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:5","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"分隔线 有时候为了排版漂亮, 需要加入分隔线. markdown使用下面两种形式之一加入分隔线 *** --- 效果如下, 分隔线语法比较松. 符号之间有空格也可以识别 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:6","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"强调 有时候, 需要对文字做强调. 使用如下方式 *这是斜体* _这是斜体_ **这是粗体** __这是粗体__ ~~删除~~ 删除 这是斜体 这是斜体 这是粗体 这是粗体 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:1:7","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"高级用法 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:0","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"mathjax 参考链接 https://jingyan.baidu.com/article/4b52d702df537efc5c774bc9.html 如果使用mathjax需要在FrontMatter中写入mathjax: true 公式标记 有两种方式 一种是行内标记用$符号表示 $(W_1−W_2)x+b_1−b_2=0$ 这是一个行内公式 $(W_1−W_2)x+b_1−b_2=0$ 一种是整行公式用两个$$ $$ (W_1−W_2)x+b_1−b_2=0 $$ 效果如下 $$ (W_1−W_2)x+b_1−b_2=0 $$ 特殊符号 名称 大写 写法 小写 写法 alpha A A α \\alpha beta B B β \\beat gamma Γ \\Gamma γ \\gamma delta Δ \\Delta δ \\delta epsilon E E ϵ \\epsilon zeta Z Z ζ \\zeta eta H H η \\eta theta Θ \\Theta θ \\theta iota I I ι \\iota kappa K K κ \\kappa lambda Λ \\Lambda λ \\lambda mu M M μ \\mu nu N N ν \\nu xi Ξ \\Xi ξ \\xi omicron O O ο \\omicron pi Π \\Pi π \\pi rho P P ρ \\rho sigma Σ \\Sigma σ \\sigma tau T T τ \\tau upsilon Υ \\Upsilon υ \\upsilon phi Φ \\Phi ϕ \\phi chi X X χ \\chi psi Ψ \\Psi ψ \\psi omega Ω \\Omega ω \\omega 上标/下标 上标和下标分别使用^和_来实现 $x_i^2=10$ $log_2^x=16$ 效果如下 $x_i^2=10$ $log_2^x=16$ 上下标默认只读后面一个字符, 如果有多个字符需要用{}包裹 $10^{10}$ $10^10$ 效果如: $10^{10}$ $10^10$ 如果左右两边都要有上下标 ${^1_2}A{^3_4}$ 效果如${^1_2}A{^3_4}$ 括号 小括号与方括号: 使用原始的小括号和方括号即可 $(2+3)[4+4]$ 大括号: 需要使用转义符号\\{和\\} 如: $\\{ab\\}$ = ${ab}$ 尖括号: 使用\\langle和\\rangle分别表示左尖括号和右尖括号$\\langle x \\rangle$ == $\\langle x \\rangle$ 上取整: 使用\\lceil和\\rceil表示. 如: $\\lceil x \\rceil$ == $\\lceil x \\rceil$ 下取整: 使用\\lfloor和\\rfloor表示. 如 $\\lfloor x \\rfloor$ = $\\lfloor x \\rfloor$ 需要注意原始括号不会根据公式的大小缩放. 可以使用\\left(…\\right)来缩放. 如: $\\left( \\frac1{\\frac12} \\right)$ 和 $(\\frac1{\\frac12})$ 求和/积分/多重积分 \\sum表示求和, 下标表示求和下限, 上标表示求和上限 $\\sum_1^n$ 效果如: $\\sum_1^n$ \\int表示求积分, 下标表示求和下限, 上标表示求和上限 $\\int_1^\\infty$ 效果如: $\\int_1^\\infty$ \\iint表示求积分, 下标表示求和下限, 上标表示求和上限 $\\iint_1^\\infty$ 效果如: $\\iint_1^\\infty$ 类似标签 $\\prod_1^n$ == ∏ $\\bigcup$ == ⋃ $\\bigcap$ == ⋂ $\\iint$ == ∬ $\\approx$ == ≈ $\\times$ == × $\\partial$ == ∂ $\\vec{a}$ $1 \\choose n$ $\\hat{y}$ $\\overline{y}$ $\\underline{abc}$ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ \\end{bmatrix} $$ $$ f(x) = \\begin{cases} x + 1 \u0026 x \\gt 1 \\\\ 2x \u0026 others \\end{cases} $$ 效果如: $\\prod_1^n$ $\\bigcup$ $\\bigcap$ $\\iint$ $\\approx$ $\\times$ $\\partial$ $\\vec{a}$ $1 \\choose n$ $\\hat{y}$ $\\overline{y}$ $\\underline{abc}$ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\ 4 \u0026 5 \u0026 6 \\ \\vdots \u0026 \\vdots \u0026 \\vdots \\ \\end{bmatrix} $$ $$ f(x) = \\begin{cases} x + 1 \u0026 x \\gt 1 \\ 2x \u0026 others \\end{cases} $$ 分式/根式 分式两种方式: 使用$\\frac ab$, 结果为$\\frac ab$. 如果分子分母不是单个字符需要用{} 使用\\over来分隔, ${a+1\\over b+1}$ == ${a+1\\over b+1}$ 根式用\\$\\sqrt[a]b\\$表示: 其中，方括号内的值用来表示开几次方，省略方括号则表示开方, 如: 例一: \\$\\sqrt[4]{\\frac xy}\\$ == $\\sqrt[4]{\\frac xy}$ 例二: \\$\\sqrt{x^3}\\$ == $\\sqrt{x^3}$ ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:1","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"插入代码块 行内代码, 单组反引号 代码块, 两个以上反引号包裹 这是一段var x=3行内代码 以下是代码块 fun(x: Int, y:Int): Int { return x + y } ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:2","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"插入表格 表头|条目一|条目二 :---:|:---:|:---: 项目|项目一|项目二 以上标记显示效果如下: 表头 条目一 条目二 项目 项目一 项目二 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:3","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"流程图 详见 https://mermaidjs.github.io/ ...mermaid ...请替换成反引号 graph TD client1--\u003e|read / write|SVN((SVN server)) client2--\u003e|read only|SVN client3--\u003e|read / write|SVN client4--\u003e|read only|SVN client5(...)--\u003eSVN SVN---|store the data|sharedrive ... 效果如下 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:4","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"甘特图 ...mermaid 将...替换成反引号 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d ... 效果如下 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:5","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"UML序列图 语法参考：https://bramp.github.io/js-sequence-diagrams/ sequenceDiagram participant Alice participant Bob Alice-\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 效果如下 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:2:6","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"其它 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:3:0","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"特殊符号处理 \\反斜杠插入用到的特殊符号,主要用到以下几种特殊符号 \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:3:1","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"给文字上色 使用html方式给文字上色 \u003cfont color='#ff0000'\u003e测试红色\u003c/font\u003e 效果如下 测试红色 ","date":"2022-09-17","objectID":"/2022/09/markdown_review/:3:2","tags":null,"title":"Markdown复习","uri":"/2022/09/markdown_review/"},{"categories":null,"content":"语言无关性 ","date":"2019-08-01","objectID":"/2019/08/java_class_file_analysis/:0:1","tags":["JVM","Java","Class文件"],"title":"Java Class文件结构","uri":"/2019/08/java_class_file_analysis/"},{"categories":null,"content":"文件结构 u1 = 1byte 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count-1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count magic u4 0xCAFEEBABE constant_pool_count u2 常量池中, 常量的个数 constant_pool cp_info CONSTANT_Utf8 1 UTF-8编码的Unicode字符串 CONSTANT_Integer 3 int类型的字面值 CONSTANT_Float 4 float类型的字面值 CONSTANT_Long 5 long类型的字面值 CONSTANT_Double 6 double类型的字面值 CONSTANT_Class 7 对一个类或接口的符号引用 CONSTANT_String 8 String类型字面值的引用 CONSTANT_Fieldref 9 对一个字段的符号引用 CONSTANT_Methodref 10 对一个类中方法的符号引用 CONSTANT_InterfaceMethodref 11 对一个接口中方法的符号引用 CONSTANT_NameAndType 12 对一个字段或方法的部分符号引用 access flag u2: 类的标示符 flag name value interpretation ACC_PUBLIC 0x0001 public ACC_FINAL 0x0010 final,不能被继承 ACC_SUPER 0x0020 是否允许使用invokespecial指令,jdk1.2后,该值为true ACC_INTERFACE 0x0200 是否是接口 ACC_ABSTRACT 0x0400 抽象类 ACC_SYNTHETIC 0x1000 该类不是由用户代码生成,运行时生成的,没有源码 ACC_ANNOTATION 0x2000 是否为注解 ACC_ENUM 0x4000 是否为枚举 this_class u2 指向常量池的Class super_class u2 指向常量池的Class interface_count u2 接口数量 interfaces interfaces_count 个interface u2 每个interface是指向CONSTANT_Class的索引 field_count 字段数量 fields field_count个field_info field access_flags u2 name_index u2 descriptor_index u2 attributes_count u2 attribute_info attributes[attributes_count]; ","date":"2019-08-01","objectID":"/2019/08/java_class_file_analysis/:0:2","tags":["JVM","Java","Class文件"],"title":"Java Class文件结构","uri":"/2019/08/java_class_file_analysis/"},{"categories":null,"content":"线程安全 多线程网站统计访问人数 使用锁, 维护计数器的串行访问与安全性 多线程方位ArrayList public static List\u003cInteger\u003e numberList = new ArrayList\u003cInteger\u003e(); public static class AddToList implements Runnable{ int startnum=0; public AddToList(int startnumber){ startnum=startnumber; } @Override public void run(){ int count=0; while(count\u003c1000000){ numberList.add(startnum); startnum+=2; count++; } } } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(new AddToList(0)); Thread t2 = new Thread(new AddToList(1)); t1.start(); t2.start(); while(t1.isAlive()||t2.isAlive()){ Thread.sleep(1); } System.out.println(numberList.size()); } ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:1","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"对象头Mark Mark Word , 对象头的标记, 32位 描述对象的hash, 锁信息, 垃圾回收标记, 年龄 指向锁记录的指针 指向monitor的治身 GC标记 偏向锁线程ID ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:2","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"偏向锁 大部分情况是没有竞争的, 所以可以通过偏向来提高性能 所谓偏向, 就是偏心, 即锁会偏向于当前已经占有锁的线程 将对象头Mark标记设置为偏向, 并将线程ID写入对象头Mark 只要没有竞争, 获得偏向锁的线程,在将来进入同步块,不需要做同步 当其他线程请求相同的锁时, 偏向模式结束 -XX:+UseBiasedLocking 默认启用 在竞争激烈的场合, 偏向锁会增加系统负担 // -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 public static List\u003cInteger\u003e numberList = new Vector\u003cInteger\u003e(); public static voi main(String[] args) throws InterruptedException { long begin = System.currentTimeMills(); int count = 0; int startnum = 0; while(count\u003c 10000000){ numberLis.add(startnum); startnum+=2 count++; } long end = System.currentTimeMillis(); System.out.println(end-begin); } ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:3","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"轻量级锁 BasicObjectLock 嵌在线程栈中的对象 普通锁的处理性能不够理想,轻量级锁是一种快速锁定的方法 如果对象没有被锁定 将对象头的Mark指针保存到锁对象 将对象头设置为指向锁的指针(在线程栈空间中) lock-\u003eset_displaced_header(mark); if(mark== (markOop)Atomic::cmpxchg_ptr(lock,obj()-\u003emark_addr(),mark)){ TEVENT(slow_enter: release stacklock); return; } 如果轻量级锁失败,表示存在竞争,升级为重量级锁(常规锁) 在没有锁竞争的前提下,减少传统锁使用OS互斥产生的性能损耗 在竞争激烈时,轻量级锁会做很多额外操作,导致性能下降 ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:4","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"自旋锁 当竞争存在时, 如果香橙可以很快获得锁, 那么可以不在OS层挂起线程, 让线程做几个空操作(自旋) JDK 1.6 中通过 -XX:+UseSpinning开启 JDK 1.7中去掉此参数, 内置默认开启 如果同步块很长,自旋失败,会降低系统性能 如果同步块很短,自旋成功, 节省线程挂起切换时间,提升系统性能 ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:5","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"偏向锁,轻量级锁,自旋锁总结 不是Java语言层面的锁优化方案 内置于JVM中的获取锁的优化方法和获取锁的步骤 偏向锁可用会现场时偏向锁 轻量级锁可用会先尝试轻量级锁 以上都失败,尝试自旋锁 再失败,尝试普通锁,使用OS互斥量操作系统层挂起 ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:6","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"java语言层面优化 减少锁持有时间 //修改前 public synchronized void syncMethod(){ othercode1(); mutextMethod(); othercode2(); } //修改后 public void syncMethod2(){ othercode1(); synchronized(this){ mutextMethod(); } othercode2(); } 减小锁粒度 将大对象,拆成小对象,大大增加并行度,降低锁竞争 偏向锁, 轻量级锁成功率提高 ConcurrentHashMap HashMap的同步实现 Collections.synchronizedMap(Map\u003cK,V\u003e m) 返回SynchronizedMap对象 public V get(Object key){ synchronized(mutext){ return m.get(key); } } public V pug(K key, V value){ synchronized(mutext){ return m.put(key,value); } } ConcurrentHashMap 分成若干个Segment: Segment\u003cK,V\u003e [] segments Segment中维护HashEntry\u003cK,V\u003e put操作时: 先定位到Segment, 锁定一个Segment, 执行put 在减小锁粒度后, ConcurrentHashMap允许若干个线程同时进入 锁分离 根据功能进行锁分离 ReadWriteLock 读多写少的情况,可以提高性能 略 读锁 写锁 读锁 可访问 不可访问 写锁 不可访问 不可访问 读写分离思想可以延伸, 只要操作互不影响,锁就可以分离 LinkedBlockingQueue 队列 链表 ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:7","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"锁粗化 通常情况下, 为了保证多线程间的有效并发,会要求每个线程持有锁的时间尽量短,即在使用完公共资源后,应该立即释放锁.只有这样,等待在这个锁上的其他线程才能尽早获得资源执行任务. 但是,凡事都有一个度,如果对同一个锁不停的进行请求,同步和释放, 其本身也会消耗系统宝贵资源,反而不利于性能的优化 // 优化前 public void demoMethod(){ synchronized(lock){ //do sth. } //做其他不需要的同步工作,但能很快执行完毕 synchronized(lock){ //do sth. } } //优化后 public void demoMethod(){ //整合成一次锁请求 synchronized(lock){ //do sth //do other } } ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:8","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"锁消除 在即时编译器时,如果发现不可能被共享的对象,则可以消除这些对象的锁操作 // CIRCLE=2000000 // -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks 187ms // -server -XX:+DoEscapeAnalysis -XX:-EliminateLocks 254ms public static void main(String args[]) throws InterruptedException { long start = System.currentTimeMillis(); for(int i = 0;i\u003cCIRCLE;i++){ createStringBuffer(\"JVM\",\"Diagnosis\"); } long bufferCost = System.currentTimeMillis(); System.out.println(\"createStringBuffer:\" + bufferCost + \" ms\"); } public static String createStringBuffer(String s1, String s2){ StringBuffer sb = new StringBuffer(); sb.append(s1); // append 方法内置synchronize锁,但是这里是失效的 sb.append(s2); return sb.toString(); } ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:9","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"无锁 锁是悲观的操作 无锁是乐观的操作 无锁的一种实现方式 CAS(Compare And Swap) 非阻塞的同步 CAS(Valve,Expect,NewValue) 在应用层面判断多线程的干扰,如果有干扰,则通知线程重试 java.util.concurrent.atomic.AtomicInteger public final int getAndSet(int new Value){ for(;;){ int current = get(); if(compareAndSet(current,newValue)) return current; } } ","date":"2019-07-20","objectID":"/2019/07/jvm_lock/:0:10","tags":["JVM","Java"],"title":"JVM锁","uri":"/2019/07/jvm_lock/"},{"categories":null,"content":"MAT使用基础 Memory Analyse Tool 浅堆(Shallow Heap) 一个对象结构所占用的内存大小 3个int类型以及一个引用类型合计占用3*4+4=16字节, 再加上对象头的8个字节,因此String对象占用的控件,即浅堆的大小是16+8=24字节 对象大小按照8字节对齐 浅堆大小和对象的内容无关, 只和对象的结构有关 深堆(Retained Heap) 一个对象被GC后,可以真实释放的内存大小 只能通过对象访问到的(直接或者间接)所有对象和浅堆之和(支配树) 显示入引用(incoming)和出引用(outgoing) 支配树 对象引用图中, 所有指向对象B的路径都经过对象A, 则认为对象A支配对象B 如果对象A是离对象B最近的一个支配对象,则认为对象A为对象B的直接支配者 支配者被回收, 被支配者也被回收 对象引用图 支配树 ","date":"2019-07-14","objectID":"/2019/07/jvm_heap_analysis/:0:1","tags":["Java","JVM"],"title":"Java堆分析","uri":"/2019/07/jvm_heap_analysis/"},{"categories":null,"content":"系统性能监控 uptime 系统时间 运行时间 连接数: 每个终端算一个连接数 1/5/15分钟系统平均负载 top 第一行同uptime cpu内存 每个进程占CPU的情况 vmstat 可以统计系统的CPU, 内存, swap, io等情况 CPU占用率很高, 上下文切换频繁, 说明系统有线程正在频繁切换 pidstat 细致观察进程 需要安装 监控CPU 监控IO 监控内存 ","date":"2019-07-13","objectID":"/2019/07/jvm_performance_monitor/:0:1","tags":["JVM","Java","监控工具"],"title":"JVM性能监控工具","uri":"/2019/07/jvm_performance_monitor/"},{"categories":null,"content":"Java自带工具 jdk安装目录下的tools目录下. jps 列出java进程, 类似ps命令 -q指定jps只输出进程ID, 不输出类的短名称 -m输出传递给Java进程(主函数)的参数 -l可以用于输出主函数的完整路径 -v可以显式传递给JVM的参数 jinfo 可以用来查看正在运行的Java应用程序的扩展参数, 甚至支持在运行时,修改部分参数 -flag \u003cname\u003e : 打印指定的JVM的参数值 -flag [+|-] \u003cname\u003e: 指定JVM参数的布尔值 -flag \u003cname\u003e=\u003cvalue\u003e: 设置指定JVM参数的值 # 显示新生代对象晋升到老年代对象的最大年龄 jinfo -flag MaxTenuringThreshold 2972 -XX:MaxTenuringThreshold=15 # 显示是否打印GC详细信息 jinfo -flag PrintGCDetails 2972 -XX:-PrintGCDetails # 运行时修改参数, 控制是否输出GC日志 jinof -flag PrintGCDetails 2972 -XX:-PrintGCDetails jinfo -flag +PrintGCDetails 2972 jinfo -flag PrintGCDetails 2972 -XX:+PrintGCDetails jmap 生成Java应用程序的堆快照和对象的统计信息 jmap -histo 2972 \u003ec:\\s.txt dump堆出来 jamp -dump:format=b,file=c:\\heap.hprof 2972 jstack 打印线程dump -l打印锁信息 -m打印java和native的帧信息 -F强制dump,当jstack没有响应时使用 JConsole 图形化监控工具 可以查看Java应用程序的运行概况, 监控堆信息,永久区使用情况, 类加载情况等 Visual VM jvisualvm Visual VM: 是一种功能强大的多合一故障诊断和性能监控工具 ","date":"2019-07-13","objectID":"/2019/07/jvm_performance_monitor/:0:2","tags":["JVM","Java","监控工具"],"title":"JVM性能监控工具","uri":"/2019/07/jvm_performance_monitor/"},{"categories":null,"content":"TODO TProfiler ","date":"2019-07-13","objectID":"/2019/07/jvm_performance_monitor/:0:3","tags":["JVM","Java","监控工具"],"title":"JVM性能监控工具","uri":"/2019/07/jvm_performance_monitor/"},{"categories":null,"content":"class装载验证流程 加载 装载类的第一阶段 取得类的二进制流 转为方法区数据结构 在Java堆中生成对应的java.lang.Class对象 链接 验证 目的: 保证Class流的格式是正确的 文件格式的验证 持否以0xCAFEBABE开头 版本号时候合理 元数据验证 是否有父类 继承了final类? 非抽象类是否实现了所有的抽象方法 字节码验证(很复杂) 运行检查 栈数据类型和操作码数据参数吻合 跳转指令指定到合理的位置 符号引用验证 常量池中描述类是否存在 访问的方法或字段是否存在且有足够的权限 准备 分配内存,并为类设置初始值(方法区中) public static int v=1 在准备阶段中, v会被设置为0 在初始化的clinit中才会被设置为1 对于static final类型, 在准备阶段就会被赋为正常的值 public static final int v=1 解析 符号引用替换为直接引用 符号引用: 字符串引用对象不一定被加载 直接引用: 指针或者地址偏移量, 引用对象一定在内存 初始化 执行类构造器clinit static变量 赋值语句 static{}语句 子类的clinit调用前保证父类的clinit被调用 clinit是线程安全的 ","date":"2019-07-09","objectID":"/2019/07/java_class_loader/:0:1","tags":["Java","JVM","类装载器"],"title":"Java 类装载器","uri":"/2019/07/java_class_loader/"},{"categories":null,"content":"什么是类装载器ClassLoader ClassLoader是一个抽象类 ClassLoader的实例将读入Java字节码将类装载到JVM中 ClassLoader可以定制,满足不同的字节码流获取方式 ClassLoader负责类装在过程中的加载阶段 ClassLoader的重要方法 //载入并返回一个Class public Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException //定义一个类,不公开调用 protected final Class\u003c?\u003e defineClass(byte[] b, int off, int len) //loadClass回调该方法,自定义ClassLoader的推荐方法 protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException //寻找已经加载的类 protected final Class\u003c?\u003e findLoadedClass(String name) ","date":"2019-07-09","objectID":"/2019/07/java_class_loader/:0:2","tags":["Java","JVM","类装载器"],"title":"Java 类装载器","uri":"/2019/07/java_class_loader/"},{"categories":null,"content":"JDK中的ClassLoader默认设计模式 ClassLoader分类 BootStrap ClassLoader(启动ClassLoader) Extension ClassLoader(扩展ClassLoader) App ClassLoader(应用ClassLoader/系统ClassLoader) Custom ClassLoader(自定义ClassLoader) 每个ClassLoader都有一个Parent作为父亲 ClassLoader的协同工作 从Custom -\u003e BootStrap 的顺序检查类是否已经加载 从BootStrap -\u003e Custom 尝试加载类 BootStrap默认加载rt.jar中的类, 我们可以使用 -Xbootclasspath指定加载类的外部路径 Extension默认加载 %JAVA_HOME%/lib/ext/*.jar App 默认加载Classpath下的类 // 在 -Xbootclasspath条件下, 强制加载某个类 public static void main(String[] args) throws Exception{ ClassLoader cl = FindClassOrder2.class.getClassLoaer(); byte[] bHelloLoaer = loadClassBytes(\"geym.jvm.ch6.findorder.HelloLoader\"); Method md_defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); md_defineClass.setAccessible(true); md_defineClass.invoke(cl, bHelloLoader, 0, bHelloLoader.length); md_defineClass.setAccessible(false); HelloLoader loader = new HelloLoader(); System.out.println(loader.getClass().getClassLoader()); loader.print(); } 问题 双亲模式的问题: 顶层ClassLoader, 无法加载底层ClassLoader的类 javax.xml.parser包中定义了xml解析类的接口Service Provider Interface SPI位于rt.jar. 接口在ClassLoader中. SPI实现类,在AppLoader 解决 Thread.setContextClassLoader() 上下文加载器 是一个\"角色\" 用以解决顶层ClassLoader无法访问底层ClassLoader的问题 基本思想是,在顶层ClassLoader中,传入底层ClassLoader的实例 双亲模式的破坏 双清模式是默认的模式,但是不是必须这么做 Tomcat的WebappClassLoader就会先加载自己的Class, 找不到在委托parent OSGi的ClassLoader形成网状结构,根据需要自由加载Class //OrderClassLoader的实现. 破坏双亲模式,先从底层ClassLoader加载 protected synchronize Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { //First, check if the class has already been loaded Class re = findClass(name); if(re==null){ System.out.println(\"无法载入类:\" + name + \"需要请求父加载器\"); return super.loadClass(name, resolve); } return re; } protected Class\u003c?\u003e findClass(String className) throws ClassNotFoundException { Class clazz = this.findLoadedClass(className); if(null==clazz){ try{ String classFile = getClassFile(className); FileInputStream fis = new FileInputStream(classFile); FileChannel fileC = fis.getChannel(); ByteArrayOutputStream baos = new ByteArrayOuntputStream(); WritableByteChannel outC = Channels.newChannel(baos); ByteBuffer buffer = ByteBuffer.allocateirect(1024); ... fis.close(); byte[] bytes = baos.toByteArray(); clazz = defineClass(className, bytes, 0, bytes.length); }catch(FileNotFoundException e){ e.printStackTrace(); }catch(IOException e){ e.printStackTrace(); } } return clazz; } ","date":"2019-07-09","objectID":"/2019/07/java_class_loader/:0:3","tags":["Java","JVM","类装载器"],"title":"Java 类装载器","uri":"/2019/07/java_class_loader/"},{"categories":null,"content":"热替换 含义: 当一个class被替换后, 系统无需重启, 替换的类立即生效 public class CVersionA { public void sayHello(){ System.out.print(\"hello world! (version A)\"); } } ","date":"2019-07-09","objectID":"/2019/07/java_class_loader/:0:4","tags":["Java","JVM","类装载器"],"title":"Java 类装载器","uri":"/2019/07/java_class_loader/"},{"categories":null,"content":"堆回顾 ","date":"2019-07-09","objectID":"/2019/07/java_gc_params/:0:1","tags":["Java","JVM","GC"],"title":"Java GC参数","uri":"/2019/07/java_gc_params/"},{"categories":null,"content":"串行收集器 最古老, 最稳定 效率高 可能会产生较长的停顿 -XX:+UseSerialGC 新生代,老年代使用串行回收 新生代复制算法 老年代标记-压缩 ","date":"2019-07-09","objectID":"/2019/07/java_gc_params/:0:2","tags":["Java","JVM","GC"],"title":"Java GC参数","uri":"/2019/07/java_gc_params/"},{"categories":null,"content":"并行收集器 ParNew -XX:+UseParNewGC 新生代并行,老年代串行 Serial收集器新生代的并行版本 复制算法 多线程,需要多核支持 -XX:ParallelGCThreads 限制线程数量 Parallel收集器 类似ParNew 新生代复制算法 老年代 标记-压缩 更加关注吞吐量 -XX:+UseParallelGC 使用Parallel收集器+老年代串行 -XX:+UseParallelOldGC 使用Parallel收集器+并行老年代 -XX:MaxGCPauseMills 最大停顿时间, 单位毫秒 尽力保证回收时间不超过设定值 -XX:GCTimeRatio 0-100取值范围, 垃圾收集时间占总时间的比,默认99即最大允许1%时间做GC 以上两个指标是矛盾的, 不能对停顿时间和吞吐量同时长调优 ","date":"2019-07-09","objectID":"/2019/07/java_gc_params/:0:3","tags":["Java","JVM","GC"],"title":"Java GC参数","uri":"/2019/07/java_gc_params/"},{"categories":null,"content":"CMS收集器 Concurrent Mark Sweep 并发标记清除 标记-清除算法 与标记-压缩相比 并发阶段会降低吞吐量 老年代收集器(新生代使用ParNew) -XX:+UseConcMarkSweepGC CMS运行过程复杂, 着重实现了标记的过程, 可分为 初始标记 根可以直接关联到对象, 速度快 并发标记(和用户线程一起) 主要标记过程,标记全部对象 重新标记 由于并发标记时,用户线程依然运行, 在正式清理之前,再做修正 并发清除(和用户线程一起) 基于标记结果,直接清理对象 特点 尽可能降低停顿 会影响系统整体吞吐量和性能 清理不彻底 因为和用户线程一起执行,不能在空间快满时再清理 -XX:CMSInitiatingOccupancyFraction 设置触发GC的阈值 使用串行收集器作为后备 有关碎片 标记-清除 会产生碎片 标记-压缩 -XX:+UseCMSCompactAtFullCollection Full GC后,进行一次整理 整理过程是独占的,会引起停顿时间变长 -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后,进行一次碎片整理 -XX:ParallelCMSThreads 设置CMS的线程数量 减轻GC压力 软件架构设计 代码如何写 堆空间的分配 ","date":"2019-07-09","objectID":"/2019/07/java_gc_params/:0:4","tags":["Java","JVM","GC"],"title":"Java GC参数","uri":"/2019/07/java_gc_params/"},{"categories":null,"content":"GC的概念 java中,GC的对象是堆空间和永久区 ","date":"2019-07-09","objectID":"/2019/07/java_gc_algo_n_category/:0:1","tags":["Java","JVM","GC"],"title":"Java GC算法与种类","uri":"/2019/07/java_gc_algo_n_category/"},{"categories":null,"content":"GC算法 引用计数法 没有被java采用 通过引用计数来回收垃圾, 但是有问题: 引用和去引用伴随加法和减法,影响性能 很难处理循环引用的问题 标记清除 现代垃圾回收算法的思想基础. 将垃圾回收分为两个阶段: 标记阶段 在标记阶段,首先通过根节点, 标记所有从根节点开始的可达对象. 因此,未被标记的对象就是未被引用的垃圾对象 清除阶段 清除所有未被标记的对象 标记压缩 适用于存活对象比较多的场合. 在标记-清除算法的基础上做了一些优化. 首先要从根节点开始,对所有可达对象做一次标记. 但之后不是简单的清理未标记的对象,而是将所有的存活对象压缩到内存的一端. 之后清理边界外所有空间 复制算法 与标记-清除算法相比, 复制算法是一种相对高效的回收算法 不适用于存活对象较多的长河, 如老年代 将原有的内存空间分为两块. 每次只使用其中一块, 在垃圾回收时, 将正在使用的内存中的存活对象复制到未使用额内存块中, 之后, 清除正在使用的内存块中的所有对象, 交换两个内存的角色, 完成垃圾回收 最大的问题是: 空间浪费, 整合标记清理思想 分代思想 根据对象的存活周期进行分类, 短命对象归为新生代, 长命对象归为老年代 根据不同代的特点, 选取合适的回收算法 少量对象存活,适合复制算法 大量对象存活,适合标记清理或者标记压缩 ","date":"2019-07-09","objectID":"/2019/07/java_gc_algo_n_category/:0:2","tags":["Java","JVM","GC"],"title":"Java GC算法与种类","uri":"/2019/07/java_gc_algo_n_category/"},{"categories":null,"content":"可触及性 所的算法, 需要能够识别一个垃圾对象, 因此需要给出一个可触及性的定义 可触及的: 从根节点可以触及到这个对象 可复活的: 一旦所有引用被释放,就是可复活状态, 因为在finalize()中可能复活该对象 不可触及的: 在finalize()后,可能会进入不可触及状态, 不可触及的对象不可能复活, 可以回收 /* finalize方法只会被调用一次 */ public class CanReliveObj{ public static CanReliveObj obj; @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"CanReliveObj finize called\"); obj = this; } @Override public String toString(){ return \"I am CanReliveObj\"; } } public static void main(String[] args) throws InterruptedException{ obj = new CarReliveObj(); obj = null; //可复活 System.gc(); Thread.sleep(1000); if(obj==null){ System.out.println(\"obj is null\"); }else{ System.out.println(\"obj is no null\"); } System.out.println(\"第二次GC\"); obj = null; //不可复活 System.gc(); Thread.sleep(1000); if(obj==null){ System.out.println(\"obj is null\"); }else{ System.out.println(\"obj is no null\"); } } 经验: 避免使用finalize(), 操作不慎可能导致错误 优先级低, 何时被调用, 不确定. 因为GC不确定 使用try-catch-finally替代它 根: 栈中引用的对象 方法区中静态成员或者常量引用的对象(全局对象) JNI方法栈中引用对象 ","date":"2019-07-09","objectID":"/2019/07/java_gc_algo_n_category/:0:3","tags":["Java","JVM","GC"],"title":"Java GC算法与种类","uri":"/2019/07/java_gc_algo_n_category/"},{"categories":null,"content":"Stop-The-World JAVA中一种全局暂停的现象 全局停顿, 所有Java代码停止, native代码可以执行, 但不能和JVM交互 多半由GC引起(其它的情况如下) dump线程 死锁检查 堆dump 危害 长时间服务停止,没有响应 遇到HA系统,可能引起主备切换,严重危害生产环境 ","date":"2019-07-09","objectID":"/2019/07/java_gc_algo_n_category/:0:4","tags":["Java","JVM","GC"],"title":"Java GC算法与种类","uri":"/2019/07/java_gc_algo_n_category/"},{"categories":null,"content":"Trace跟踪参数 -verbose:gc -XX:+PrintGC 可以打印GC的简要信息 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印GC发生的时间戳 -Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题 -XX:+PrintHeapAtGC 每一次GC后,都打印堆信息 -XX:+TraceClassLoading 监控类的加载 -XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型 ","date":"2019-07-08","objectID":"/2019/07/jvm_common_opts/:0:1","tags":["Java","JVM","参数调优"],"title":"JVM常用运行参数","uri":"/2019/07/jvm_common_opts/"},{"categories":null,"content":"堆的分配参数 -Xmx 最大堆 -Xms 最小堆 System.out.print(\"Xmx=\"); System.out.println(Runtime.getRuntime().maxMemory()/1024/1024 + \"M\"); System.out.print(\"free mem=\"); System.out.println(Runtime.getRuntime().freeMemory()/1024/1024 + \"M\"); System.out.print(\"total mem=\"); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024 + \"M\"); -Xmn 设置新生代大小,是一个绝对值 -XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10 /* 通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC -Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代 -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用 -Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保 -Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大 -Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails */ public static void main(String[] args){ byte[] b= null; for(int i=0;i\u003c10;i++){ b = new byte[1*1024*1024]; } } -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 导出OOM的路径 /* -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump */ Vector v = new Vector(); for(int i =0;i\u003c25;i++){ v.add(new byte[1*1024*1024]); } -XX:OnOutOfMemoryError 在OOM的时候, 执行一个脚本. -XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstatck.bat %p # 打印线程信息, 这个脚本可以是发送邮件甚至是重启程序 官方推荐新生代占堆的3/8, 幸存代占新生代的1/10. OOM时,记得Dump出堆, 确保可以排查现场问题 ","date":"2019-07-08","objectID":"/2019/07/jvm_common_opts/:0:2","tags":["Java","JVM","参数调优"],"title":"JVM常用运行参数","uri":"/2019/07/jvm_common_opts/"},{"categories":null,"content":"永久区分配参数 -XX:PermSize -XX:MaxPermSize 设置永久区的初始控件大小和最大空间大小. 他们表示一个系统可以容纳多少个类型 /* 使用CGLIB等库的时候,可能会产生大量的类. 这些类有可能承包永久区导致OOM */ for(int i=0;i\u003c100000;i++){ CglibBean bean = new CglibBean(\"geym.jvm.ch3.perm.bean\"+ i, new HashMap()); } 以上表示: 堆空间实际占用非常少, 但是永久区溢出,一样会出现OOM的情况 ","date":"2019-07-08","objectID":"/2019/07/jvm_common_opts/:0:3","tags":["Java","JVM","参数调优"],"title":"JVM常用运行参数","uri":"/2019/07/jvm_common_opts/"},{"categories":null,"content":"栈的分配参数 -Xss 通常只有几百k 决定了函数的深度 每个线程有独立的栈空间 局部变量,参数分配在栈上 ","date":"2019-07-08","objectID":"/2019/07/jvm_common_opts/:0:4","tags":["Java","JVM","参数调优"],"title":"JVM常用运行参数","uri":"/2019/07/jvm_common_opts/"},{"categories":null,"content":"JVM运行机制 PC寄存器 每个线程拥有一个PC寄存器 在线程创建时创建 总是指向下一条指令的地址 执行本地方法时, PC的值为undefined 方法区 保存装载的类信息 类型的常量池 字段, 方法信息 方法字节码 通常和永久区关联在一起 java堆 和程序开发密切相关 应用系统对象都保存在java堆中 所有线程共享java堆 对分代GC来说, 堆也是分代 GC的主要工作区间: eden|s0|s1|tenured java栈 线程私有 栈由一系列帧组成(因此java栈也叫做栈帧) 帧保存一个方法的局部变量,操作数栈,常量池指针 每一次方法调用创建一个帧,并压栈 java栈之局部变量表(包含参数和局部变量) public class StackDemo { /* 假设局部变量表里是一个槽位, 每个槽位最大容纳32位的数据*/ /* 静态方法的局部变量表为: 0 int int i 1 long long l 2 float float f 3 reference Object o 4 int byte b */ public static int run Static(int i, long l, float f, Object o, byte b){ return 0; } /* 实例方法的局部变量表为: 0 reference this 当前对象的引用 1 int char c 2 int short s 3 int boolean bµ */ public int runInstance(char c, short s, boolean b){ return 0; } } java栈之函数调用组成帧栈(包括操作数栈和返回地址) /* 函数调用过程, 会压栈 */ public static int runStatic(int i, long l, float f, Object o, byte b){ return runStatic(i, l, f, o, b); } java栈之操作数栈 /* java没有寄存器, 所有参数传递使用操作数栈 以下方法的操作数栈情况: 0 iconst_0 0压栈 1 istore_2 弹出int,存放于局部变量2 2 iload_0 把局部变量0压栈 3 iload_1 把局部变量1压栈 4 iadd 弹出2个变量,求和,结果压栈 5 istore_2 弹出结果,放于局部变量2 6 iload_2 局部变量2压栈 7 ireturn 返回 */ public static int add(int a, int b){ int c = 0; c = a + b; return c; } java栈之栈上分配 class BcmBasicString{...} /* 堆上分配, 每次要手动清理内存 */ public void method(){ BcmBasicString* str = new BcmBasicString; ... delete str; } /* 栈上分配, 不会出现内存泄漏 */ public void method(){ BcmBasicString str; ... } 栈上分配特点 小对象(一般几十个bytes), 在没有逃逸的情况下, 可以直接分配在栈上 直接分配在栈上, 可以自动回收, 减轻GC压力 大对象或者逃逸对象(即会被共享的对象)无法栈上分配 堆, 栈, 方法区交互 public class AppMain{ //运行时, jvm把appmain的信息都放入方法区 public static void main(String[] args){ //test1是引用, 放到栈区, Sample是自定义对象, 放到堆里面 Sample test1 = new Sample(\"test1\"); Sample test2 = new Sample(\"test2\"); test1.printName(); test2.printName(); } } public class Sample{ //运行时, jvm把sample的信息都放入方法区 // new Sample实例后, name引用放到栈区里, name对象放到堆里 private String name; public Sample(String name){ this.name = name; } // print 方法本身放入方法区里 public void printName(){ System.out.println(name); } } 内存模型 每一个线程有一个工作从内存和主存独立 工作内存存放主存中变量值的拷贝 当数据从\"主内存\"复制到\"线程工作内存\"时, 必须出现两个动作: 主内存执行的(read)操作 工作内存执行相应的load操作 当数据从\"线程工作内存\"拷贝到\"主内存\"时, 也出现两个动作: 工作内存执行store操作 主内存执行相应的写write操作 每个操作都是原子的, 即执行期间不会被中断 对于普通变量, 一个线程中更新的值,不能马上反应在其他变量中. 如果需要在其他线程中立即课件, 需要使用volatile关键字 volatile /* volatile 不能替代锁, 一般认为volatile比锁性能好(不绝对) 选择使用volatile的条件是: 语义是否满足应用, 它是线程不安全的 */ public class VolatileStopThread extends Thread{ private volatile boolean stop = false; public void stopMe(){ stop = true; } public void run(){ int i = 0; while(!stop){ i++; } System.out.println(\"Stop thread\"); } public static void main(String[] args) throws InterruptedException{ VolatileStopThread t = new VolatileStopThread(); t.start(); Thread.sleep(1000); t.stopMe(); Thread.sleep(1000); } } 可见性 一个线程修改了变量, 其他线程可以立即知道 保证可见性的方法 volatile synchronized(unlock之前, 写变量值回主存) final(一旦初始化完成,其它线程就可见) 有序性 在本线程内,操作都是有序的 在线程外观察,操作都是无序的(指令重排 或 主内存同步延时) 指令重排的基本原则 程序顺序原则: 一个线程内保证语义的串行性 volatile规则: volatile变量的写, 先发生于读 锁规则: 解锁(unlock)必然发生在随后的加锁(lock)前 传递性: A先于B, B先于C 那么A必然先于C 线程的start方法先于它的每一个动作 线程的所有操作先于线程的终结(Thread.join()) 线程的中断(interrupte())先于被中断线程的代码 对象的构造函数执行先于finalize()方法 解释执行 解释执行以解释方式运行字节码 解释执行的意思是: 读一句执行一句 编译运行(JIT) 将字节码编译成机器码 直接执行机器码 运行时编译 编译后性能有数量级的提升 ","date":"2019-07-08","objectID":"/2019/07/jvm_basics/:0:1","tags":["Java","JVM"],"title":"JVM运行机制","uri":"/2019/07/jvm_basics/"},{"categories":["机器学习"],"content":"问题模型 ","date":"2019-06-08","objectID":"/2019/06/ml_video15_hidden_marcov_model/:0:1","tags":["机器学习","隐马尔可夫"],"title":"机器学习-视频学习系列15-隐马尔可夫模型","uri":"/2019/06/ml_video15_hidden_marcov_model/"},{"categories":["机器学习"],"content":"模型公式 目标: 求$P(x_t|y_{1:t})$ 步骤: predict 求$P(x_t|y_{1:t-1})$ 使用到恒等变形公式: $P(A|BC)$ $= \\frac{P(ABC)}{P(BC)}$ $= \\frac{P(B|AC)P(A|C)P(C)}{P(B|C)P(C)}$ $= \\frac{P(B|AC)P(A|C)}{P(B|C)}$ update 求$P(x_t|y_{1:t})$ 依旧使用上面的恒等变形公式: $P(x_t|y_{1:t}) = P(x_t|y_t,y_{t-1})$ $=$ ","date":"2019-06-08","objectID":"/2019/06/ml_video15_hidden_marcov_model/:0:2","tags":["机器学习","隐马尔可夫"],"title":"机器学习-视频学习系列15-隐马尔可夫模型","uri":"/2019/06/ml_video15_hidden_marcov_model/"},{"categories":["机器学习"],"content":"机器学习的四种paradigms 连接主义(connectionist) aka 深度学习,神经网络. 认为表示学习非常重要. 需要学出来一个分布式的表示(distributed representation). Tensorflow PyTorch Theano Caffe 符号主义 Prolog 基于逻辑的学习 统计学习 基于统计学的基本假设 SVM, 统计学习理论, vc-dimention 概率图模型 GAN VAE ","date":"2019-06-07","objectID":"/2019/06/ml_video114_bias_newwork/:0:1","tags":["机器学习","贝叶斯网络"],"title":"机器学习-视频学习系列14-贝叶斯网络","uri":"/2019/06/ml_video114_bias_newwork/"},{"categories":["机器学习"],"content":"贝叶斯公式 $P(A|B)=\\frac{P(B|A) * P(A)}{P(B)}$ ","date":"2019-06-07","objectID":"/2019/06/ml_video114_bias_newwork/:0:2","tags":["机器学习","贝叶斯网络"],"title":"机器学习-视频学习系列14-贝叶斯网络","uri":"/2019/06/ml_video114_bias_newwork/"},{"categories":["机器学习"],"content":"概率图模型 以高效的方法求变量的联合分布 DAG(Directed Acyclic Graph) 有向无环图 Node-随机变量, Edges-边 上帝视角的P(B,E,A,R,C) $X_i$和$X_{ancestors}|X_{parents}$独立 $P(B,E,A,R,C)$ $=P(B)P(E|B)P(A|B,E)P(R|A,B,E)P(C|R,A,B,E)$ $=P(B)P(E)P(A|B,E)P(R|E)P(C|A)$ DAG能够告诉我们 如果我们有n个变量$x_i$,那么这些变的联合概率分布可以拆解为: $P(X_{1:n})=P(x_1,x_2,\\cdots,x_n)=\\prod_{i=1}^nP(x_i|parents(x_i))$ ","date":"2019-06-07","objectID":"/2019/06/ml_video114_bias_newwork/:0:3","tags":["机器学习","贝叶斯网络"],"title":"机器学习-视频学习系列14-贝叶斯网络","uri":"/2019/06/ml_video114_bias_newwork/"},{"categories":["机器学习"],"content":"概率图模型求法 概率图模型的求法: 消元法 aka(动态规划) aka(分配律) 动态规划的思想在: 概率图模型, HMM, VC-dimension, RL中的MDP, 神经网络BP中的DP 这几块用过 ","date":"2019-06-07","objectID":"/2019/06/ml_video114_bias_newwork/:0:4","tags":["机器学习","贝叶斯网络"],"title":"机器学习-视频学习系列14-贝叶斯网络","uri":"/2019/06/ml_video114_bias_newwork/"},{"categories":["机器学习"],"content":"聚类 ","date":"2019-06-07","objectID":"/2019/06/ml_video12_aggregation/:1:0","tags":["机器学习","聚类","视频"],"title":"机器学习-视频学习系列12-聚类","uri":"/2019/06/ml_video12_aggregation/"},{"categories":["机器学习"],"content":"基于对象的聚类(Objective based clustering) K-means 聚类 k-means 问题描述: 找到cpt1,cpt2,….cpt, 使 $ min\\sum_{i=1}^n m_{j \\in 1 \\cdots k} d^2(x^i,c_j) $ k-median 问题描述: 找到cpt1,cpt2,….cpt, 使 $ min\\sum_{i=1}^n m_{j \\in 1 \\cdots k} d(x^i,c_j) $ k-center 问题描述: 找到一个分类方式最小化最大半径 Lloyds method: 总是收敛的(目标函数单调递减,并且有下界, 该方法一定收敛) 问题描述: Input: 一组数据集 $ x^1, x^2, \\cdots, x^n \\in R^d$ Initialize: 1. 中心点 $c_1, c_2, \\cdots, c_k \\in R^d$ 2. 簇$C_1,C_2,\\cdots,C_k$以随机方式聚合 Repeat:直到目标函数没有任何变化 1. for each j: $C_j \\in {x \\in S }$ where closest center is $c_j$ 2. for each j: $c_j \\in avg(c_j)$ 初始化很重要(决定了收敛的快慢和输出的质量), 常用的有三种: 随机挑选中心化点. performance 比较差. 随着k的增大, 效果指数级下降 对于k个高斯分布来说, 每个初始化的中心正好在一个不同的高斯分布的概率$\\approx\\frac {k!}{k^k}\\approx\\frac1{e^k}$ 最远遍历(Furthest Point Heuristic) 先固定一个$c_j$,然后在后续每次取中心点的时候, 都评估距离已经选出来的点最远的点作为当前的中心点. 以此类推, 选出k个中心点. 解决了高斯分布的问题, 但是可能对噪声(outlier)特别敏感 K-means++ (效果好, 效率快): 基本思路$D^{\\alpha}$抽样 理论上 K-means++ 会得到O(logk)的最优解. 如果$\\alpha$=0, 就是随机抽样 如果$\\alpha$=$\\infin$, 就是最远点初始化 如果$\\alpha$=2, k-means++ K-means++/Lloyd’s 运行的时间复杂度 K-means++ 初始化: O(nkd) ,其中n是样本点个数,k是聚类个数, d是样本维度 如何选择k 交叉验证 Elbow’s method. 找到不同k之间的损失函数下降最快的地方. 尝试层次聚类 ","date":"2019-06-07","objectID":"/2019/06/ml_video12_aggregation/:1:1","tags":["机器学习","聚类","视频"],"title":"机器学习-视频学习系列12-聚类","uri":"/2019/06/ml_video12_aggregation/"},{"categories":["机器学习"],"content":"层次聚类(Hierarchical clustering) 主要讲由下至上的层次聚类 1:34:16 to be continue ","date":"2019-06-07","objectID":"/2019/06/ml_video12_aggregation/:1:2","tags":["机器学习","聚类","视频"],"title":"机器学习-视频学习系列12-聚类","uri":"/2019/06/ml_video12_aggregation/"},{"categories":["机器学习"],"content":"K-means 代码分析及实现 ","date":"2019-06-07","objectID":"/2019/06/ml_video12_aggregation/:1:3","tags":["机器学习","聚类","视频"],"title":"机器学习-视频学习系列12-聚类","uri":"/2019/06/ml_video12_aggregation/"}]