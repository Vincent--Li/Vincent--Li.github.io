<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="3.2 程序编码 # long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; } # 生成汇编代码 -> .s gcc -Og -S mstore.c # 生成目标代码 -> .o gcc -Og -c mstore.c # 查看机器码内容 objdump -d mstore.o 3.3 数据格式 # 3.4 访问信息 # 一个 x86_64 CPU 包含一组16个村粗64位值的通用目的寄存器. 这些寄存器用来存储整数数据和指针
字节级操作可以访问最低的字节 16位操作可以访问最低的2个字节 32位操作可以访问最低的4个字节 64位操作可以访问整个寄存器
最特别的: 栈指针 %rsp, 用来指明运行时栈的结束位置
3.4.1 操作数指示符 # 不同的操作数的可能性被分为三种类型:
立即数(immediate): 表示常数值, 书写方式是&rsquo;$&rsquo; 后面跟一个用标准C表示法表示的整数."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/posts/csapp/mlrp/"><meta property="og:title" content="CSAPP: Machine-Level Representation of Programs"><meta property="og:description" content="3.2 程序编码 # long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; } # 生成汇编代码 -> .s gcc -Og -S mstore.c # 生成目标代码 -> .o gcc -Og -c mstore.c # 查看机器码内容 objdump -d mstore.o 3.3 数据格式 # 3.4 访问信息 # 一个 x86_64 CPU 包含一组16个村粗64位值的通用目的寄存器. 这些寄存器用来存储整数数据和指针
字节级操作可以访问最低的字节 16位操作可以访问最低的2个字节 32位操作可以访问最低的4个字节 64位操作可以访问整个寄存器
最特别的: 栈指针 %rsp, 用来指明运行时栈的结束位置
3.4.1 操作数指示符 # 不同的操作数的可能性被分为三种类型:
立即数(immediate): 表示常数值, 书写方式是’$’ 后面跟一个用标准C表示法表示的整数."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-30T20:41:22+08:00"><meta property="article:modified_time" content="2022-09-30T20:41:22+08:00"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="机器语言"><title>CSAPP: Machine-Level Representation of Programs | </title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=/posts/csapp/mlrp/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.8aa13e2f4b9fdd1fa1c269db82d4ba6bb2746e64391b4052adb11ab4309caef3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>CSAPP: Machine-Level Representation of Programs</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#32-程序编码>3.2 程序编码</a></li><li><a href=#33-数据格式>3.3 数据格式</a></li><li><a href=#34-访问信息>3.4 访问信息</a><ul><li><a href=#341-操作数指示符>3.4.1 操作数指示符</a></li><li><a href=#342-数据传送指令>3.4.2 数据传送指令</a></li><li><a href=#343-数据传送示例>3.4.3 数据传送示例</a></li><li><a href=#344-压入和弹出栈数据>3.4.4 压入和弹出栈数据</a></li></ul></li><li><a href=#35-算术和逻辑操作>3.5 算术和逻辑操作</a><ul><li><a href=#351-加载有效地址>3.5.1 加载有效地址</a></li><li><a href=#352-一元和二元操作>3.5.2 一元和二元操作</a></li><li><a href=#353-移位操作>3.5.3 移位操作</a></li><li><a href=#354-讨论>3.5.4 讨论</a></li><li><a href=#355-特殊的算术操作>3.5.5 特殊的算术操作</a></li></ul></li><li><a href=#36-控制>3.6 控制</a></li></ul></nav></aside></header><article class="markdown book-post"><h1><a href=/posts/csapp/mlrp/>CSAPP: Machine-Level Representation of Programs</a></h1><h5>September 30, 2022</h5><div><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div><div><a href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>,
<a href=/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/>机器语言</a></div><h2 id=32-程序编码>3.2 程序编码
<a class=anchor href=#32-%e7%a8%8b%e5%ba%8f%e7%bc%96%e7%a0%81>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>mult2</span>(<span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>long</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>multstore</span>(<span style=color:#66d9ef>long</span> x, <span style=color:#66d9ef>long</span> y, <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>dest) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> t <span style=color:#f92672>=</span> <span style=color:#a6e22e>mult2</span>(x, y);
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>dest <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 生成汇编代码 -&gt; .s</span>
</span></span><span style=display:flex><span>gcc -Og -S mstore.c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 生成目标代码 -&gt; .o</span>
</span></span><span style=display:flex><span>gcc -Og -c mstore.c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看机器码内容 </span>
</span></span><span style=display:flex><span>objdump -d mstore.o
</span></span></code></pre></div><h2 id=33-数据格式>3.3 数据格式
<a class=anchor href=#33-%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f>#</a></h2><p><img src=/images/2022-10-07-00-28-58.png alt=图1></p><h2 id=34-访问信息>3.4 访问信息
<a class=anchor href=#34-%e8%ae%bf%e9%97%ae%e4%bf%a1%e6%81%af>#</a></h2><p>一个 x86_64 CPU 包含一组16个村粗64位值的通用目的寄存器. 这些寄存器用来存储整数数据和指针</p><p>字节级操作可以访问最低的字节
16位操作可以访问最低的2个字节
32位操作可以访问最低的4个字节
64位操作可以访问整个寄存器</p><p><img src=/images/2022-10-07-00-37-20.png alt=寄存器></p><p>最特别的: 栈指针 %rsp, 用来指明运行时栈的结束位置</p><h3 id=341-操作数指示符>3.4.1 操作数指示符
<a class=anchor href=#341-%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8c%87%e7%a4%ba%e7%ac%a6>#</a></h3><p>不同的操作数的可能性被分为三种类型:</p><ol><li>立即数(immediate): 表示常数值, 书写方式是&rsquo;$&rsquo; 后面跟一个用标准C表示法表示的整数. 不同的指令允许的立即数值范围不同, 汇编器会自动选择最紧凑的方式进行数值编码</li><li>寄存器(register): 16个寄存器的低1字节, 2字节, 4字节或8字节中的一个作为操作数. 分别对应8位, 16位, 32位, 64位. 我们用$r_a$表示任意寄存器a, 用过引用$R[r_a]$表示它的值. 即, 将寄存器集合看成一个数组R,用寄存器标识符作为索引.</li><li>内存引用: 根据计算出来的地址(通常称为有效地址)访问某个内存位置. 因为将内存看成一个很大的字节数组, 我们用符号$M_b[Addr]$表示对存储在内存地址Addr开始的b个字节值的引用.</li></ol><p>图3-3中. 底部$Imm(r_b, r_i, s)$表示的是最常用的形式:</p><ol><li>立即数偏移Imm</li><li>基址寄存器$r_b$(64位)</li><li>变址寄存器$r_i$(64位)</li><li>比例因子: 必须是 1, 2, 4, 8</li></ol><p><img src=/images/2022-10-07-12-10-22.png alt></p><h3 id=342-数据传送指令>3.4.2 数据传送指令
<a class=anchor href=#342-%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e6%8c%87%e4%bb%a4>#</a></h3><p><img src=/images/2022-10-07-21-56-24.png alt>
<img src=/images/2022-10-07-21-57-17.png alt></p><h3 id=343-数据传送示例>3.4.3 数据传送示例
<a class=anchor href=#343-%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e7%a4%ba%e4%be%8b>#</a></h3><p>注意:</p><ol><li>c语言所谓的指针, 其实就是地址. 间接引用指针就是将该指针放在一个寄存器中, 然后在内存引用中使用这个寄存器</li><li>像x这样的局部变量, 通常是保存在寄存器中, 而不是内存中. 访问寄存器比访问内存要快得多</li></ol><p><img src=/images/2022-10-07-22-16-22.png alt></p><h3 id=344-压入和弹出栈数据>3.4.4 压入和弹出栈数据
<a class=anchor href=#344-%e5%8e%8b%e5%85%a5%e5%92%8c%e5%bc%b9%e5%87%ba%e6%a0%88%e6%95%b0%e6%8d%ae>#</a></h3><p>栈向下增长, 栈顶元素的地址是所有占中元素地址最低的. 栈指针%rsp保存栈顶元素的地址</p><p><img src=/images/2022-10-07-23-52-14.png alt></p><p><img src=/images/2022-10-07-23-53-16.png alt></p><p>栈和程序代码以及其它形式的程序数据都放在同一个内存中, 所以程序可以用标准的内存寻址方法访问栈内的任意位置.</p><h2 id=35-算术和逻辑操作>3.5 算术和逻辑操作
<a class=anchor href=#35-%e7%ae%97%e6%9c%af%e5%92%8c%e9%80%bb%e8%be%91%e6%93%8d%e4%bd%9c>#</a></h2><p>以下指令都有不同大小操作数的变种(leaq除外). 例如ADD: addb, addw, addl, addq
<img src=/images/2022-10-08-00-01-52.png alt></p><h3 id=351-加载有效地址>3.5.1 加载有效地址
<a class=anchor href=#351-%e5%8a%a0%e8%bd%bd%e6%9c%89%e6%95%88%e5%9c%b0%e5%9d%80>#</a></h3><p>leaq(load effective address 加载有效地址).实际是movq指令的变形. 虽然形式是从内存读数据到寄存器, 但是实际上根本没有引用过内存. 编译器进场发现一些leaq的灵活用法, 和有效地址计算无关. 目的操作数必须是一个寄存器</p><p>设: %rdx = x, %rcx = y</p><p>则: leaq 7(%rdx, %rcx, 4) = 7 + x + y * 4 = x +4y + 7</p><p><img src=/images/2022-10-08-00-24-33.png alt></p><p>leaq指令能执行加法和有限形式的乘法, 在编译简单的算术表达式的时候, 很有用处</p><h3 id=352-一元和二元操作>3.5.2 一元和二元操作
<a class=anchor href=#352-%e4%b8%80%e5%85%83%e5%92%8c%e4%ba%8c%e5%85%83%e6%93%8d%e4%bd%9c>#</a></h3><p>略. 注意二元操作的第一个操作数 和 第二个操作数的关系.以及 结果需要写回D即可</p><p>是 D op S -> D</p><h3 id=353-移位操作>3.5.3 移位操作
<a class=anchor href=#353-%e7%a7%bb%e4%bd%8d%e6%93%8d%e4%bd%9c>#</a></h3><p>略</p><h3 id=354-讨论>3.5.4 讨论
<a class=anchor href=#354-%e8%ae%a8%e8%ae%ba>#</a></h3><p>略</p><h3 id=355-特殊的算术操作>3.5.5 特殊的算术操作
<a class=anchor href=#355-%e7%89%b9%e6%ae%8a%e7%9a%84%e7%ae%97%e6%9c%af%e6%93%8d%e4%bd%9c>#</a></h3><p><img src=/images/2022-10-10-23-44-36.png alt></p><h2 id=36-控制>3.6 控制
<a class=anchor href=#36-%e6%8e%a7%e5%88%b6>#</a></h2></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#32-程序编码>3.2 程序编码</a></li><li><a href=#33-数据格式>3.3 数据格式</a></li><li><a href=#34-访问信息>3.4 访问信息</a><ul><li><a href=#341-操作数指示符>3.4.1 操作数指示符</a></li><li><a href=#342-数据传送指令>3.4.2 数据传送指令</a></li><li><a href=#343-数据传送示例>3.4.3 数据传送示例</a></li><li><a href=#344-压入和弹出栈数据>3.4.4 压入和弹出栈数据</a></li></ul></li><li><a href=#35-算术和逻辑操作>3.5 算术和逻辑操作</a><ul><li><a href=#351-加载有效地址>3.5.1 加载有效地址</a></li><li><a href=#352-一元和二元操作>3.5.2 一元和二元操作</a></li><li><a href=#353-移位操作>3.5.3 移位操作</a></li><li><a href=#354-讨论>3.5.4 讨论</a></li><li><a href=#355-特殊的算术操作>3.5.5 特殊的算术操作</a></li></ul></li><li><a href=#36-控制>3.6 控制</a></li></ul></nav></div></aside></main></body></html>