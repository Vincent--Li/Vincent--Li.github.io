<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='Trace跟踪参数 # -verbose:gc -XX:+PrintGC 可以打印GC的简要信息 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印GC发生的时间戳 -Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题 -XX:+PrintHeapAtGC 每一次GC后,都打印堆信息 -XX:+TraceClassLoading 监控类的加载 -XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型 堆的分配参数 # -Xmx 最大堆 -Xms 最小堆 System.out.print("Xmx="); System.out.println(Runtime.getRuntime().maxMemory()/1024/1024 + "M"); System.out.print("free mem="); System.out.println(Runtime.getRuntime().freeMemory()/1024/1024 + "M"); System.out.print("total mem="); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024 + "M"); -Xmn 设置新生代大小,是一个绝对值 -XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10 /* 通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC -Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代 -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用 -Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保 -Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大 -Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails */ public static void main(String[] args){ byte[] b= null; for(int i=0;i<10;i++){ b = new byte[1*1024*1024]; } } -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 导出OOM的路径 /* -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/posts/java/jvm_common_opts/"><meta property="og:title" content="JVM常用运行参数"><meta property="og:description" content='Trace跟踪参数 # -verbose:gc -XX:+PrintGC 可以打印GC的简要信息 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印GC发生的时间戳 -Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题 -XX:+PrintHeapAtGC 每一次GC后,都打印堆信息 -XX:+TraceClassLoading 监控类的加载 -XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型 堆的分配参数 # -Xmx 最大堆 -Xms 最小堆 System.out.print("Xmx="); System.out.println(Runtime.getRuntime().maxMemory()/1024/1024 + "M"); System.out.print("free mem="); System.out.println(Runtime.getRuntime().freeMemory()/1024/1024 + "M"); System.out.print("total mem="); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024 + "M"); -Xmn 设置新生代大小,是一个绝对值 -XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10 /* 通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC -Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代 -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用 -Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保 -Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大 -Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails */ public static void main(String[] args){ byte[] b= null; for(int i=0;i<10;i++){ b = new byte[1*1024*1024]; } } -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 导出OOM的路径 /* -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-08T20:23:02+00:00"><meta property="article:modified_time" content="2019-07-08T20:23:02+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta property="article:tag" content="参数调优"><title>JVM常用运行参数 | </title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=/posts/java/jvm_common_opts/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.8aa13e2f4b9fdd1fa1c269db82d4ba6bb2746e64391b4052adb11ab4309caef3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>JVM常用运行参数</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#trace跟踪参数>Trace跟踪参数</a></li><li><a href=#堆的分配参数>堆的分配参数</a></li><li><a href=#永久区分配参数>永久区分配参数</a></li><li><a href=#栈的分配参数>栈的分配参数</a></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h1><a href=/posts/java/jvm_common_opts/>JVM常用运行参数</a></h1><h5>July 8, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a></div><h3 id=trace跟踪参数>Trace跟踪参数
<a class=anchor href=#trace%e8%b7%9f%e8%b8%aa%e5%8f%82%e6%95%b0>#</a></h3><ul><li>-verbose:gc</li><li>-XX:+PrintGC</li><li>可以打印GC的简要信息</li><li>-XX:+PrintGCDetails 打印GC详细信息</li><li>-XX:+PrintGCTimeStamps 打印GC发生的时间戳</li><li>-Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题</li><li>-XX:+PrintHeapAtGC 每一次GC后,都打印堆信息</li><li>-XX:+TraceClassLoading 监控类的加载</li><li>-XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型</li></ul><h3 id=堆的分配参数>堆的分配参数
<a class=anchor href=#%e5%a0%86%e7%9a%84%e5%88%86%e9%85%8d%e5%8f%82%e6%95%b0>#</a></h3><ul><li>-Xmx 最大堆</li><li>-Xms 最小堆</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;Xmx=&#34;</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>maxMemory</span>()<span style=color:#f92672>/</span>1024<span style=color:#f92672>/</span>1024 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;M&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;free mem=&#34;</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>freeMemory</span>()<span style=color:#f92672>/</span>1024<span style=color:#f92672>/</span>1024 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;M&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;total mem=&#34;</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>totalMemory</span>()<span style=color:#f92672>/</span>1024<span style=color:#f92672>/</span>1024 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;M&#34;</span>);
</span></span></code></pre></div><ul><li>-Xmn 设置新生代大小,是一个绝对值</li><li>-XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5</li><li>-XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC
</span></span></span><span style=display:flex><span><span style=color:#75715e>-Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代
</span></span></span><span style=display:flex><span><span style=color:#75715e>-Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用
</span></span></span><span style=display:flex><span><span style=color:#75715e>-Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保
</span></span></span><span style=display:flex><span><span style=color:#75715e>-Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大
</span></span></span><span style=display:flex><span><span style=color:#75715e>-Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> b<span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>10;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>1<span style=color:#f92672>*</span>1024<span style=color:#f92672>*</span>1024<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>-XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件</li><li>-XX:+HeapDumpPath 导出OOM的路径</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>Vector v <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Vector();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>25;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    v.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>1<span style=color:#f92672>*</span>1024<span style=color:#f92672>*</span>1024<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>-XX:OnOutOfMemoryError 在OOM的时候, 执行一个脚本.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>-XX:OnOutOfMemoryError<span style=color:#f92672>=</span>D:/tools/jdk1.7_40/bin/printstatck.bat %p <span style=color:#75715e># 打印线程信息, 这个脚本可以是发送邮件甚至是重启程序</span>
</span></span></code></pre></div><p>官方推荐新生代占堆的3/8, 幸存代占新生代的1/10. OOM时,记得Dump出堆, 确保可以排查现场问题</p><h3 id=永久区分配参数>永久区分配参数
<a class=anchor href=#%e6%b0%b8%e4%b9%85%e5%8c%ba%e5%88%86%e9%85%8d%e5%8f%82%e6%95%b0>#</a></h3><ul><li>-XX:PermSize -XX:MaxPermSize 设置永久区的初始控件大小和最大空间大小. 他们表示一个系统可以容纳多少个类型</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>使用CGLIB等库的时候,可能会产生大量的类. 这些类有可能承包永久区导致OOM
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>100000;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    CglibBean bean <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CglibBean(<span style=color:#e6db74>&#34;geym.jvm.ch3.perm.bean&#34;</span><span style=color:#f92672>+</span> i, <span style=color:#66d9ef>new</span> HashMap());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>以上表示: 堆空间实际占用非常少, 但是永久区溢出,一样会出现OOM的情况</li></ul><h3 id=栈的分配参数>栈的分配参数
<a class=anchor href=#%e6%a0%88%e7%9a%84%e5%88%86%e9%85%8d%e5%8f%82%e6%95%b0>#</a></h3><ul><li>-Xss</li></ul><ol><li>通常只有几百k</li><li>决定了函数的深度</li><li>每个线程有独立的栈空间</li><li>局部变量,参数分配在栈上</li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#trace跟踪参数>Trace跟踪参数</a></li><li><a href=#堆的分配参数>堆的分配参数</a></li><li><a href=#永久区分配参数>永久区分配参数</a></li><li><a href=#栈的分配参数>栈的分配参数</a></li></ul></li></ul></nav></div></aside></main></body></html>