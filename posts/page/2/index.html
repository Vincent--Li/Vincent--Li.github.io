<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/posts/"><meta property="og:title" content="Posts"><meta property="og:locale" content="en"><meta property="og:type" content="website"><title>Posts | </title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=/posts/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.8aa13e2f4b9fdd1fa1c269db82d4ba6bb2746e64391b4052adb11ab4309caef3.js></script><link rel=alternate type=application/rss+xml href=/posts/index.xml title></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Posts</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul><li class="flex justify-between"><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>4</span></li><li class="flex justify-between"><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/>机器语言</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/class%E6%96%87%E4%BB%B6/>Class文件</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/java/>Java</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/jvm/>JVM</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/>监控工具</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/>类装载器</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gc/>GC</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/>隐马尔可夫</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/>贝叶斯网络</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%81%9A%E7%B1%BB/>聚类</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%A7%86%E9%A2%91/>视频</a>
<span>1</span></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=/posts/java/java_gc_params/>Java GC参数</a></h2><h5>July 9, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/gc/>GC</a></div><p>堆回顾 # 串行收集器 # 最古老, 最稳定 效率高 可能会产生较长的停顿 -XX:+UseSerialGC 新生代,老年代使用串行回收 新生代复制算法 老年代标记-压缩 并行收集器 # ParNew -XX:+UseParNewGC 新生代并行,老年代串行 Serial收集器新生代的并行版本 复制算法 多线程,需要多核支持 -XX:ParallelGCThreads 限制线程数量 Parallel收集器 类似ParNew 新生代复制算法 老年代 标记-压缩 更加关注吞吐量 -XX:+UseParallelGC 使用Parallel收集器+老年代串行 -XX:+UseParallelOldGC 使用Parallel收集器+并行老年代 -XX:MaxGCPauseMills 最大停顿时间, 单位毫秒 尽力保证回收时间不超过设定值 -XX:GCTimeRatio 0-100取值范围, 垃圾收集时间占总时间的比,默认99即最大允许1%时间做GC 以上两个指标是矛盾的, 不能对停顿时间和吞吐量同时长调优 CMS收集器 # Concurrent Mark Sweep 并发标记清除 标记-清除算法 与标记-压缩相比 并发阶段会降低吞吐量 老年代收集器(新生代使用ParNew) -XX:+UseConcMarkSweepGC CMS运行过程复杂, 着重实现了标记的过程, 可分为 初始标记 根可以直接关联到对象, 速度快 并发标记(和用户线程一起) 主要标记过程,标记全部对象 重新标记 由于并发标记时,用户线程依然运行, 在正式清理之前,再做修正 并发清除(和用户线程一起) 基于标记结果,直接清理对象 特点 尽可能降低停顿 会影响系统整体吞吐量和性能 清理不彻底 因为和用户线程一起执行,不能在空间快满时再清理 -XX:CMSInitiatingOccupancyFraction 设置触发GC的阈值 使用串行收集器作为后备 有关碎片 标记-清除 会产生碎片 标记-压缩 -XX:+UseCMSCompactAtFullCollection Full GC后,进行一次整理 整理过程是独占的,会引起停顿时间变长 -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后,进行一次碎片整理 -XX:ParallelCMSThreads 设置CMS的线程数量 减轻GC压力 软件架构设计 代码如何写 堆空间的分配</p></article><article class="markdown book-post"><h2><a href=/posts/java/java_gc_algo_n_category/>Java GC算法与种类</a></h2><h5>July 9, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/gc/>GC</a></div><p>GC的概念 # java中,GC的对象是堆空间和永久区 GC算法 # 引用计数法 没有被java采用 # 通过引用计数来回收垃圾, 但是有问题:
引用和去引用伴随加法和减法,影响性能 很难处理循环引用的问题 标记清除 # 现代垃圾回收算法的思想基础. 将垃圾回收分为两个阶段:
标记阶段
在标记阶段,首先通过根节点, 标记所有从根节点开始的可达对象. 因此,未被标记的对象就是未被引用的垃圾对象 清除阶段 清除所有未被标记的对象 标记压缩 # 适用于存活对象比较多的场合. 在标记-清除算法的基础上做了一些优化. 首先要从根节点开始,对所有可达对象做一次标记. 但之后不是简单的清理未标记的对象,而是将所有的存活对象压缩到内存的一端. 之后清理边界外所有空间
复制算法 # 与标记-清除算法相比, 复制算法是一种相对高效的回收算法 不适用于存活对象较多的长河, 如老年代 将原有的内存空间分为两块. 每次只使用其中一块, 在垃圾回收时, 将正在使用的内存中的存活对象复制到未使用额内存块中, 之后, 清除正在使用的内存块中的所有对象, 交换两个内存的角色, 完成垃圾回收 最大的问题是: 空间浪费, 整合标记清理思想 分代思想 # 根据对象的存活周期进行分类, 短命对象归为新生代, 长命对象归为老年代 根据不同代的特点, 选取合适的回收算法 少量对象存活,适合复制算法 大量对象存活,适合标记清理或者标记压缩 可触及性 # 所的算法, 需要能够识别一个垃圾对象, 因此需要给出一个可触及性的定义
可触及的: 从根节点可以触及到这个对象 可复活的: 一旦所有引用被释放,就是可复活状态, 因为在finalize()中可能复活该对象 不可触及的: 在finalize()后,可能会进入不可触及状态, 不可触及的对象不可能复活, 可以回收 /* finalize方法只会被调用一次 */ public class CanReliveObj{ public static CanReliveObj obj; @Override protected void finalize() throws Throwable { super.
<a href=/posts/java/java_gc_algo_n_category/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_common_opts/>JVM常用运行参数</a></h2><h5>July 8, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a></div><p>Trace跟踪参数 # -verbose:gc -XX:+PrintGC 可以打印GC的简要信息 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印GC发生的时间戳 -Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题 -XX:+PrintHeapAtGC 每一次GC后,都打印堆信息 -XX:+TraceClassLoading 监控类的加载 -XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型 堆的分配参数 # -Xmx 最大堆 -Xms 最小堆 System.out.print("Xmx="); System.out.println(Runtime.getRuntime().maxMemory()/1024/1024 + "M"); System.out.print("free mem="); System.out.println(Runtime.getRuntime().freeMemory()/1024/1024 + "M"); System.out.print("total mem="); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024 + "M"); -Xmn 设置新生代大小,是一个绝对值 -XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10 /* 通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC -Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代 -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用 -Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保 -Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大 -Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails */ public static void main(String[] args){ byte[] b= null; for(int i=0;i&lt;10;i++){ b = new byte[1*1024*1024]; } } -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 导出OOM的路径 /* -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.
<a href=/posts/java/jvm_common_opts/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_basics/>JVM运行机制</a></h2><h5>July 8, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a></div><p>JVM运行机制 # PC寄存器 # 每个线程拥有一个PC寄存器 在线程创建时创建 总是指向下一条指令的地址 执行本地方法时, PC的值为undefined 方法区 # 保存装载的类信息 类型的常量池 字段, 方法信息 方法字节码 通常和永久区关联在一起 java堆 # 和程序开发密切相关 应用系统对象都保存在java堆中 所有线程共享java堆 对分代GC来说, 堆也是分代 GC的主要工作区间: eden|s0|s1|tenured java栈 # 线程私有 栈由一系列帧组成(因此java栈也叫做栈帧) 帧保存一个方法的局部变量,操作数栈,常量池指针 每一次方法调用创建一个帧,并压栈 java栈之局部变量表(包含参数和局部变量) # public class StackDemo { /* 假设局部变量表里是一个槽位, 每个槽位最大容纳32位的数据*/ /* 静态方法的局部变量表为: 0 int int i 1 long long l 2 float float f 3 reference Object o 4 int byte b */ public static int run Static(int i, long l, float f, Object o, byte b){ return 0; } /* 实例方法的局部变量表为: 0 reference this 当前对象的引用 1 int char c 2 int short s 3 int boolean bµ */ public int runInstance(char c, short s, boolean b){ return 0; } } java栈之函数调用组成帧栈(包括操作数栈和返回地址) # /* 函数调用过程, 会压栈 */ public static int runStatic(int i, long l, float f, Object o, byte b){ return runStatic(i, l, f, o, b); } java栈之操作数栈 # /* java没有寄存器, 所有参数传递使用操作数栈 以下方法的操作数栈情况: 0 iconst_0 0压栈 1 istore_2 弹出int,存放于局部变量2 2 iload_0 把局部变量0压栈 3 iload_1 把局部变量1压栈 4 iadd 弹出2个变量,求和,结果压栈 5 istore_2 弹出结果,放于局部变量2 6 iload_2 局部变量2压栈 7 ireturn 返回 */ public static int add(int a, int b){ int c = 0; c = a + b; return c; } java栈之栈上分配 # class BcmBasicString{.
<a href=/posts/java/jvm_basics/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/machine_learning/ml_video15_hidden_marcov_model/>机器学习-视频学习系列15-隐马尔可夫模型</a></h2><h5>June 8, 2019</h5><div><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a></div><div><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>,
<a href=/tags/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/>隐马尔可夫</a></div><p>问题模型 # graph LR
x1(x1)-->x2(x2)
x2-->x3(x3)
x3-->xn(xn)
x1-->y1(y1)
x2-->y2(y2)
x3-->y3(y3)
模型公式 # 目标: 求$P(x_t|y_{1:t})$ 步骤:
predict 求$P(x_t|y_{1:t-1})$ 使用到恒等变形公式: $P(A|BC)$ $= \frac{P(ABC)}{P(BC)}$ $= \frac{P(B|AC)P(A|C)P(C)}{P(B|C)P(C)}$ $= \frac{P(B|AC)P(A|C)}{P(B|C)}$
update 求$P(x_t|y_{1:t})$ 依旧使用上面的恒等变形公式: $P(x_t|y_{1:t}) = P(x_t|y_t,y_{t-1})$ $=$</p></article><article class="markdown book-post"><h2><a href=/posts/machine_learning/ml_video114_bias_newwork/>机器学习-视频学习系列14-贝叶斯网络</a></h2><h5>June 7, 2019</h5><div><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a></div><div><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>,
<a href=/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/>贝叶斯网络</a></div><p>机器学习的四种paradigms # 连接主义(connectionist) aka 深度学习,神经网络. 认为表示学习非常重要. 需要学出来一个分布式的表示(distributed representation). Tensorflow PyTorch Theano Caffe 符号主义 Prolog 基于逻辑的学习 统计学习 基于统计学的基本假设 SVM, 统计学习理论, vc-dimention 概率图模型 GAN VAE 贝叶斯公式 # $P(A|B)=\frac{P(B|A) * P(A)}{P(B)}$
概率图模型 # 以高效的方法求变量的联合分布
graph TD
Earthquake(Earthquake)-->Radio(Radio)
Earthquake-->Alarm(Alarm)
Burglary(Burglary)-->Alarm
Alarm-->Call(Call)
DAG(Directed Acyclic Graph) 有向无环图 Node-随机变量, Edges-边
上帝视角的P(B,E,A,R,C) $X_i$和$X_{ancestors}|X_{parents}$独立 $P(B,E,A,R,C)$ $=P(B)P(E|B)P(A|B,E)P(R|A,B,E)P(C|R,A,B,E)$ $=P(B)P(E)P(A|B,E)P(R|E)P(C|A)$
DAG能够告诉我们 如果我们有n个变量$x_i$,那么这些变的联合概率分布可以拆解为: $P(X_{1:n})=P(x_1,x_2,\cdots,x_n)=\prod_{i=1}^nP(x_i|parents(x_i))$
概率图模型求法 # 概率图模型的求法: 消元法 aka(动态规划) aka(分配律) 动态规划的思想在: 概率图模型, HMM, VC-dimension, RL中的MDP, 神经网络BP中的DP 这几块用过</p></article><article class="markdown book-post"><h2><a href=/posts/machine_learning/ml_video12_aggregation/>机器学习-视频学习系列12-聚类</a></h2><h5>June 7, 2019</h5><div><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a></div><div><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>,
<a href=/tags/%E8%81%9A%E7%B1%BB/>聚类</a>,
<a href=/tags/%E8%A7%86%E9%A2%91/>视频</a></div><p>聚类 # 基于对象的聚类(Objective based clustering) # K-means 聚类 # k-means 问题描述: 找到cpt1,cpt2,&mldr;.cpt, 使 $ min\sum_{i=1}^n m_{j \in 1 \cdots k} d^2(x^i,c_j) $ k-median 问题描述: 找到cpt1,cpt2,&mldr;.cpt, 使 $ min\sum_{i=1}^n m_{j \in 1 \cdots k} d(x^i,c_j) $ k-center 问题描述: 找到一个分类方式最小化最大半径 Lloyds method: 总是收敛的(目标函数单调递减,并且有下界, 该方法一定收敛) # 问题描述:
Input: 一组数据集 $ x^1, x^2, \cdots, x^n \in R^d$ Initialize: 1. 中心点 $c_1, c_2, \cdots, c_k \in R^d$ 2. 簇$C_1,C_2,\cdots,C_k$以随机方式聚合 Repeat:直到目标函数没有任何变化 1. for each j: $C_j \in {x \in S }$ where closest center is $c_j$ 2.
<a href=/posts/machine_learning/ml_video12_aggregation/>...</a></p></article><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class="page-item active"><a aria-current=page aria-label="Page 2" class=page-link role=button>2</a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Next class=page-link role=button tabindex=-1><span aria-hidden=true>&#187;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Last class=page-link role=button tabindex=-1><span aria-hidden=true>&#187;&#187;</span></a></li></ul><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul><li class="flex justify-between"><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>4</span></li><li class="flex justify-between"><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/>机器语言</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/class%E6%96%87%E4%BB%B6/>Class文件</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/java/>Java</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/jvm/>JVM</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/>监控工具</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/>类装载器</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gc/>GC</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/>隐马尔可夫</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/>贝叶斯网络</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%81%9A%E7%B1%BB/>聚类</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%A7%86%E9%A2%91/>视频</a>
<span>1</span></li></ul></li></ul></nav></div></aside></main></body></html>