<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>/</link><description>Recent content on</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 04 Oct 2022 21:04:48 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Resources</title><link>/resources/</link><pubDate>Tue, 04 Oct 2022 21:04:48 +0800</pubDate><guid>/resources/</guid><description>Book Searching # libgen.is
free-programming-books
classic cs courses (repost from 编程指北)
book list (repost from awesome-programming-books.github.io)
Learning Smart # tips for reading books (repost from 编程指北)</description></item><item><title>CSAPP: Machine-Level Representation of Programs</title><link>/posts/csapp/mlrp/</link><pubDate>Fri, 30 Sep 2022 20:41:22 +0800</pubDate><guid>/posts/csapp/mlrp/</guid><description>3.2 程序编码 # long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; } # 生成汇编代码 -&amp;gt; .s gcc -Og -S mstore.c # 生成目标代码 -&amp;gt; .o gcc -Og -c mstore.c # 查看机器码内容 objdump -d mstore.o 3.3 数据格式 # 3.4 访问信息 # 一个 x86_64 CPU 包含一组16个村粗64位值的通用目的寄存器. 这些寄存器用来存储整数数据和指针
字节级操作可以访问最低的字节 16位操作可以访问最低的2个字节 32位操作可以访问最低的4个字节 64位操作可以访问整个寄存器
最特别的: 栈指针 %rsp, 用来指明运行时栈的结束位置
3.4.1 操作数指示符 # 不同的操作数的可能性被分为三种类型:
立即数(immediate): 表示常数值, 书写方式是&amp;rsquo;$&amp;rsquo; 后面跟一个用标准C表示法表示的整数.</description></item><item><title>CSAPP: Representing and Manipulating Information</title><link>/posts/csapp/rami/</link><pubDate>Mon, 26 Sep 2022 22:35:55 +0800</pubDate><guid>/posts/csapp/rami/</guid><description>TO be continue
2.1 Information Storage #</description></item><item><title>CSAPP: A Tour of Computer Systems</title><link>/posts/csapp/introduction/</link><pubDate>Thu, 22 Sep 2022 00:10:37 +0800</pubDate><guid>/posts/csapp/introduction/</guid><description>1.1 Information is Bits + Contexts # The same bits may have different meaning under different contexts
// hello.c #include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;hello, world\n&amp;#34;); return 0; } 1.2 Programs Are Traslated by Other Programs into Different Forms # The programs that perform four phases(preprocessor, compiler, assembler, and linker) are known colletively as the compilation system
Preprocessing phase. The preprocessor(cpp) modifies the original C program according to directives that begin with the &amp;lsquo;#&amp;rsquo; character.</description></item><item><title>CSAPP: Preface</title><link>/posts/csapp/preface/</link><pubDate>Wed, 21 Sep 2022 22:41:47 +0800</pubDate><guid>/posts/csapp/preface/</guid><description>A Tour of Computer Systems # C1: A Tour of Computer Systems
Part I: Program Structure and Execution # C2: Representing and Manipulating Information
C3: Machine-Level Representation of Programs
C4: Processor Architecture
C5: Optimizing Program Performance
C6: The Memory Hierarchy
Part II: Running Prgrams on a System # C7: Linking
C8: Exceptional Control Flow
C9: Virtual Memory
Part III: Interaction and Communication between Programs # C10: System-Level I/O
C11: Network Programming</description></item><item><title>About</title><link>/about/</link><pubDate>Sun, 18 Sep 2022 00:40:34 +0800</pubDate><guid>/about/</guid><description>TEST # this is a brief test</description></item><item><title>Markdown复习</title><link>/posts/markdown/markdown_review/</link><pubDate>Sat, 17 Sep 2022 21:49:25 +0800</pubDate><guid>/posts/markdown/markdown_review/</guid><description>基础语法 # 标题 # Markdown支持6中级别的标题, 对应HTML标签h1-h6
# h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 此外, markdown还支持简单的两级标题设置
这是一级标题 === 这是二级标题 --- 段落及区块引用 # &amp;gt; 这段文字将被高亮显示 这段文字将被高亮显示
插入链接或图片 # [点击跳转至百度](http://www.baidu.com) ![图片](https://vincent--li.github.io/favicon.ico) 自动生成连接 &amp;lt;https://www.baidu.com&amp;gt; 点击跳转至百度
自动生成连接 https://www.baidu.com
注: 引用图片和链接的唯一区别就是最前面的叹号
列表 # Markdown支持有序列表和无序列表两种形式:
无序列表使用*或+或-标识 有序列表使用数字加.标识,例如1. * 黄瓜 * 玉米 * 茄子 + 黄瓜 + 玉米 + 茄子 - 黄瓜 - 玉米 - 茄子 1. 黄瓜 2. 玉米 3. 茄子 以上标记效果如下</description></item><item><title>Java Class文件结构</title><link>/posts/java/java_class_file_analysis/</link><pubDate>Thu, 01 Aug 2019 00:59:28 +0000</pubDate><guid>/posts/java/java_class_file_analysis/</guid><description>语言无关性 # graph LR A(*.java)-->D(.class) B(*.rb)-->D C(*.groovy)-->D E(其它JVM语言)-->D D-->F(JVM) 文件结构 # u1 = 1byte
类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count-1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count magic u4 # 0xCAFEEBABE constant_pool_count u2 # 常量池中, 常量的个数</description></item><item><title>JVM锁</title><link>/posts/java/jvm_lock/</link><pubDate>Sat, 20 Jul 2019 21:26:30 +0000</pubDate><guid>/posts/java/jvm_lock/</guid><description>线程安全 # 多线程网站统计访问人数 # 使用锁, 维护计数器的串行访问与安全性 多线程方位ArrayList public static List&amp;lt;Integer&amp;gt; numberList = new ArrayList&amp;lt;Integer&amp;gt;(); public static class AddToList implements Runnable{ int startnum=0; public AddToList(int startnumber){ startnum=startnumber; } @Override public void run(){ int count=0; while(count&amp;lt;1000000){ numberList.add(startnum); startnum+=2; count++; } } } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(new AddToList(0)); Thread t2 = new Thread(new AddToList(1)); t1.start(); t2.start(); while(t1.isAlive()||t2.isAlive()){ Thread.sleep(1); } System.out.println(numberList.size()); } 对象头Mark # Mark Word , 对象头的标记, 32位 描述对象的hash, 锁信息, 垃圾回收标记, 年龄 指向锁记录的指针 指向monitor的治身 GC标记 偏向锁线程ID 偏向锁 # 大部分情况是没有竞争的, 所以可以通过偏向来提高性能 所谓偏向, 就是偏心, 即锁会偏向于当前已经占有锁的线程 将对象头Mark标记设置为偏向, 并将线程ID写入对象头Mark 只要没有竞争, 获得偏向锁的线程,在将来进入同步块,不需要做同步 当其他线程请求相同的锁时, 偏向模式结束 -XX:+UseBiasedLocking 默认启用 在竞争激烈的场合, 偏向锁会增加系统负担 // -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 public static List&amp;lt;Integer&amp;gt; numberList = new Vector&amp;lt;Integer&amp;gt;(); public static voi main(String[] args) throws InterruptedException { long begin = System.</description></item><item><title>Java堆分析</title><link>/posts/java/jvm_heap_analysis/</link><pubDate>Sun, 14 Jul 2019 22:25:46 +0000</pubDate><guid>/posts/java/jvm_heap_analysis/</guid><description> MAT使用基础 Memory Analyse Tool # 浅堆(Shallow Heap) # 一个对象结构所占用的内存大小 3个int类型以及一个引用类型合计占用3*4+4=16字节, 再加上对象头的8个字节,因此String对象占用的控件,即浅堆的大小是16+8=24字节 对象大小按照8字节对齐 浅堆大小和对象的内容无关, 只和对象的结构有关 深堆(Retained Heap) # 一个对象被GC后,可以真实释放的内存大小 只能通过对象访问到的(直接或者间接)所有对象和浅堆之和(支配树) 显示入引用(incoming)和出引用(outgoing) # 支配树 # 对象引用图中, 所有指向对象B的路径都经过对象A, 则认为对象A支配对象B 如果对象A是离对象B最近的一个支配对象,则认为对象A为对象B的直接支配者 支配者被回收, 被支配者也被回收 对象引用图 # graph TD A((A))-->C((C)) B((B))-->C C-->D((D)) C-->E((E)) E-->G((G)) G-->H((H)) D-->F((F)) F-->D F-->H 支配树 # graph TD root((root))-->A((A)) root-->B((B)) root-->C((C)) C-->D((D)) C-->E((E)) C-->H((H)) D-->F((F)) E-->G((G))</description></item><item><title>JVM性能监控工具</title><link>/posts/java/jvm_performance_monitor/</link><pubDate>Sat, 13 Jul 2019 20:59:16 +0000</pubDate><guid>/posts/java/jvm_performance_monitor/</guid><description>系统性能监控 # uptime 系统时间 运行时间 连接数: 每个终端算一个连接数 1/5/15分钟系统平均负载 top 第一行同uptime cpu内存 每个进程占CPU的情况 vmstat 可以统计系统的CPU, 内存, swap, io等情况 CPU占用率很高, 上下文切换频繁, 说明系统有线程正在频繁切换 pidstat 细致观察进程 需要安装 监控CPU 监控IO 监控内存 Java自带工具 # jdk安装目录下的tools目录下.
jps # 列出java进程, 类似ps命令 -q指定jps只输出进程ID, 不输出类的短名称 -m输出传递给Java进程(主函数)的参数 -l可以用于输出主函数的完整路径 -v可以显式传递给JVM的参数 jinfo # 可以用来查看正在运行的Java应用程序的扩展参数, 甚至支持在运行时,修改部分参数 -flag &amp;lt;name&amp;gt; : 打印指定的JVM的参数值 -flag [+|-] &amp;lt;name&amp;gt;: 指定JVM参数的布尔值 -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;: 设置指定JVM参数的值 # 显示新生代对象晋升到老年代对象的最大年龄 jinfo -flag MaxTenuringThreshold 2972 -XX:MaxTenuringThreshold=15 # 显示是否打印GC详细信息 jinfo -flag PrintGCDetails 2972 -XX:-PrintGCDetails # 运行时修改参数, 控制是否输出GC日志 jinof -flag PrintGCDetails 2972 -XX:-PrintGCDetails jinfo -flag +PrintGCDetails 2972 jinfo -flag PrintGCDetails 2972 -XX:+PrintGCDetails jmap # 生成Java应用程序的堆快照和对象的统计信息 jmap -histo 2972 &amp;gt;c:\s.</description></item><item><title>Java 类装载器</title><link>/posts/java/java_class_loader/</link><pubDate>Tue, 09 Jul 2019 23:09:04 +0000</pubDate><guid>/posts/java/java_class_loader/</guid><description>class装载验证流程 # 加载 # 装载类的第一阶段 取得类的二进制流 转为方法区数据结构 在Java堆中生成对应的java.lang.Class对象 链接 # 验证 # 目的: 保证Class流的格式是正确的
文件格式的验证 持否以0xCAFEBABE开头 版本号时候合理 元数据验证 是否有父类 继承了final类? 非抽象类是否实现了所有的抽象方法 字节码验证(很复杂) 运行检查 栈数据类型和操作码数据参数吻合 跳转指令指定到合理的位置 符号引用验证 常量池中描述类是否存在 访问的方法或字段是否存在且有足够的权限 准备 # 分配内存,并为类设置初始值(方法区中) public static int v=1 在准备阶段中, v会被设置为0 在初始化的clinit中才会被设置为1 对于static final类型, 在准备阶段就会被赋为正常的值 public static final int v=1 解析 # 符号引用替换为直接引用 符号引用: 字符串引用对象不一定被加载 直接引用: 指针或者地址偏移量, 引用对象一定在内存 初始化 # 执行类构造器clinit static变量 赋值语句 static{}语句 子类的clinit调用前保证父类的clinit被调用 clinit是线程安全的 什么是类装载器ClassLoader # ClassLoader是一个抽象类 ClassLoader的实例将读入Java字节码将类装载到JVM中 ClassLoader可以定制,满足不同的字节码流获取方式 ClassLoader负责类装在过程中的加载阶段 ClassLoader的重要方法 # //载入并返回一个Class public Class&amp;lt;?</description></item><item><title>Java GC参数</title><link>/posts/java/java_gc_params/</link><pubDate>Tue, 09 Jul 2019 21:38:20 +0000</pubDate><guid>/posts/java/java_gc_params/</guid><description> 堆回顾 # 串行收集器 # 最古老, 最稳定 效率高 可能会产生较长的停顿 -XX:+UseSerialGC 新生代,老年代使用串行回收 新生代复制算法 老年代标记-压缩 并行收集器 # ParNew -XX:+UseParNewGC 新生代并行,老年代串行 Serial收集器新生代的并行版本 复制算法 多线程,需要多核支持 -XX:ParallelGCThreads 限制线程数量 Parallel收集器 类似ParNew 新生代复制算法 老年代 标记-压缩 更加关注吞吐量 -XX:+UseParallelGC 使用Parallel收集器+老年代串行 -XX:+UseParallelOldGC 使用Parallel收集器+并行老年代 -XX:MaxGCPauseMills 最大停顿时间, 单位毫秒 尽力保证回收时间不超过设定值 -XX:GCTimeRatio 0-100取值范围, 垃圾收集时间占总时间的比,默认99即最大允许1%时间做GC 以上两个指标是矛盾的, 不能对停顿时间和吞吐量同时长调优 CMS收集器 # Concurrent Mark Sweep 并发标记清除 标记-清除算法 与标记-压缩相比 并发阶段会降低吞吐量 老年代收集器(新生代使用ParNew) -XX:+UseConcMarkSweepGC CMS运行过程复杂, 着重实现了标记的过程, 可分为 初始标记 根可以直接关联到对象, 速度快 并发标记(和用户线程一起) 主要标记过程,标记全部对象 重新标记 由于并发标记时,用户线程依然运行, 在正式清理之前,再做修正 并发清除(和用户线程一起) 基于标记结果,直接清理对象 特点 尽可能降低停顿 会影响系统整体吞吐量和性能 清理不彻底 因为和用户线程一起执行,不能在空间快满时再清理 -XX:CMSInitiatingOccupancyFraction 设置触发GC的阈值 使用串行收集器作为后备 有关碎片 标记-清除 会产生碎片 标记-压缩 -XX:+UseCMSCompactAtFullCollection Full GC后,进行一次整理 整理过程是独占的,会引起停顿时间变长 -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后,进行一次碎片整理 -XX:ParallelCMSThreads 设置CMS的线程数量 减轻GC压力 软件架构设计 代码如何写 堆空间的分配</description></item><item><title>Java GC算法与种类</title><link>/posts/java/java_gc_algo_n_category/</link><pubDate>Tue, 09 Jul 2019 19:58:30 +0000</pubDate><guid>/posts/java/java_gc_algo_n_category/</guid><description>GC的概念 # java中,GC的对象是堆空间和永久区 GC算法 # 引用计数法 没有被java采用 # 通过引用计数来回收垃圾, 但是有问题:
引用和去引用伴随加法和减法,影响性能 很难处理循环引用的问题 标记清除 # 现代垃圾回收算法的思想基础. 将垃圾回收分为两个阶段:
标记阶段
在标记阶段,首先通过根节点, 标记所有从根节点开始的可达对象. 因此,未被标记的对象就是未被引用的垃圾对象 清除阶段 清除所有未被标记的对象 标记压缩 # 适用于存活对象比较多的场合. 在标记-清除算法的基础上做了一些优化. 首先要从根节点开始,对所有可达对象做一次标记. 但之后不是简单的清理未标记的对象,而是将所有的存活对象压缩到内存的一端. 之后清理边界外所有空间
复制算法 # 与标记-清除算法相比, 复制算法是一种相对高效的回收算法 不适用于存活对象较多的长河, 如老年代 将原有的内存空间分为两块. 每次只使用其中一块, 在垃圾回收时, 将正在使用的内存中的存活对象复制到未使用额内存块中, 之后, 清除正在使用的内存块中的所有对象, 交换两个内存的角色, 完成垃圾回收 最大的问题是: 空间浪费, 整合标记清理思想 分代思想 # 根据对象的存活周期进行分类, 短命对象归为新生代, 长命对象归为老年代 根据不同代的特点, 选取合适的回收算法 少量对象存活,适合复制算法 大量对象存活,适合标记清理或者标记压缩 可触及性 # 所的算法, 需要能够识别一个垃圾对象, 因此需要给出一个可触及性的定义
可触及的: 从根节点可以触及到这个对象 可复活的: 一旦所有引用被释放,就是可复活状态, 因为在finalize()中可能复活该对象 不可触及的: 在finalize()后,可能会进入不可触及状态, 不可触及的对象不可能复活, 可以回收 /* finalize方法只会被调用一次 */ public class CanReliveObj{ public static CanReliveObj obj; @Override protected void finalize() throws Throwable { super.</description></item><item><title>JVM常用运行参数</title><link>/posts/java/jvm_common_opts/</link><pubDate>Mon, 08 Jul 2019 20:23:02 +0000</pubDate><guid>/posts/java/jvm_common_opts/</guid><description>Trace跟踪参数 # -verbose:gc -XX:+PrintGC 可以打印GC的简要信息 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印GC发生的时间戳 -Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题 -XX:+PrintHeapAtGC 每一次GC后,都打印堆信息 -XX:+TraceClassLoading 监控类的加载 -XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型 堆的分配参数 # -Xmx 最大堆 -Xms 最小堆 System.out.print(&amp;#34;Xmx=&amp;#34;); System.out.println(Runtime.getRuntime().maxMemory()/1024/1024 + &amp;#34;M&amp;#34;); System.out.print(&amp;#34;free mem=&amp;#34;); System.out.println(Runtime.getRuntime().freeMemory()/1024/1024 + &amp;#34;M&amp;#34;); System.out.print(&amp;#34;total mem=&amp;#34;); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024 + &amp;#34;M&amp;#34;); -Xmn 设置新生代大小,是一个绝对值 -XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10 /* 通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC -Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代 -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用 -Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保 -Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大 -Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails */ public static void main(String[] args){ byte[] b= null; for(int i=0;i&amp;lt;10;i++){ b = new byte[1*1024*1024]; } } -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 导出OOM的路径 /* -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.</description></item><item><title>JVM运行机制</title><link>/posts/java/jvm_basics/</link><pubDate>Mon, 08 Jul 2019 09:10:50 +0000</pubDate><guid>/posts/java/jvm_basics/</guid><description>JVM运行机制 # PC寄存器 # 每个线程拥有一个PC寄存器 在线程创建时创建 总是指向下一条指令的地址 执行本地方法时, PC的值为undefined 方法区 # 保存装载的类信息 类型的常量池 字段, 方法信息 方法字节码 通常和永久区关联在一起 java堆 # 和程序开发密切相关 应用系统对象都保存在java堆中 所有线程共享java堆 对分代GC来说, 堆也是分代 GC的主要工作区间: eden|s0|s1|tenured java栈 # 线程私有 栈由一系列帧组成(因此java栈也叫做栈帧) 帧保存一个方法的局部变量,操作数栈,常量池指针 每一次方法调用创建一个帧,并压栈 java栈之局部变量表(包含参数和局部变量) # public class StackDemo { /* 假设局部变量表里是一个槽位, 每个槽位最大容纳32位的数据*/ /* 静态方法的局部变量表为: 0 int int i 1 long long l 2 float float f 3 reference Object o 4 int byte b */ public static int run Static(int i, long l, float f, Object o, byte b){ return 0; } /* 实例方法的局部变量表为: 0 reference this 当前对象的引用 1 int char c 2 int short s 3 int boolean bµ */ public int runInstance(char c, short s, boolean b){ return 0; } } java栈之函数调用组成帧栈(包括操作数栈和返回地址) # /* 函数调用过程, 会压栈 */ public static int runStatic(int i, long l, float f, Object o, byte b){ return runStatic(i, l, f, o, b); } java栈之操作数栈 # /* java没有寄存器, 所有参数传递使用操作数栈 以下方法的操作数栈情况: 0 iconst_0 0压栈 1 istore_2 弹出int,存放于局部变量2 2 iload_0 把局部变量0压栈 3 iload_1 把局部变量1压栈 4 iadd 弹出2个变量,求和,结果压栈 5 istore_2 弹出结果,放于局部变量2 6 iload_2 局部变量2压栈 7 ireturn 返回 */ public static int add(int a, int b){ int c = 0; c = a + b; return c; } java栈之栈上分配 # class BcmBasicString{.</description></item><item><title>机器学习-视频学习系列15-隐马尔可夫模型</title><link>/posts/machine_learning/ml_video15_hidden_marcov_model/</link><pubDate>Sat, 08 Jun 2019 17:34:36 +0000</pubDate><guid>/posts/machine_learning/ml_video15_hidden_marcov_model/</guid><description>问题模型 # graph LRx1(x1)-->x2(x2)x2-->x3(x3)x3-->xn(xn)x1-->y1(y1)x2-->y2(y2)x3-->y3(y3)模型公式 # 目标: 求$P(x_t|y_{1:t})$ 步骤:
predict 求$P(x_t|y_{1:t-1})$ 使用到恒等变形公式: $P(A|BC)$ $= \frac{P(ABC)}{P(BC)}$ $= \frac{P(B|AC)P(A|C)P(C)}{P(B|C)P(C)}$ $= \frac{P(B|AC)P(A|C)}{P(B|C)}$
update 求$P(x_t|y_{1:t})$ 依旧使用上面的恒等变形公式: $P(x_t|y_{1:t}) = P(x_t|y_t,y_{t-1})$ $=$</description></item><item><title>机器学习-视频学习系列14-贝叶斯网络</title><link>/posts/machine_learning/ml_video114_bias_newwork/</link><pubDate>Fri, 07 Jun 2019 23:33:54 +0000</pubDate><guid>/posts/machine_learning/ml_video114_bias_newwork/</guid><description>机器学习的四种paradigms # 连接主义(connectionist) aka 深度学习,神经网络. 认为表示学习非常重要. 需要学出来一个分布式的表示(distributed representation). Tensorflow PyTorch Theano Caffe 符号主义 Prolog 基于逻辑的学习 统计学习 基于统计学的基本假设 SVM, 统计学习理论, vc-dimention 概率图模型 GAN VAE 贝叶斯公式 # $P(A|B)=\frac{P(B|A) * P(A)}{P(B)}$
概率图模型 # 以高效的方法求变量的联合分布
graph TDEarthquake(Earthquake)-->Radio(Radio)Earthquake-->Alarm(Alarm)Burglary(Burglary)-->AlarmAlarm-->Call(Call)DAG(Directed Acyclic Graph) 有向无环图 Node-随机变量, Edges-边
上帝视角的P(B,E,A,R,C) $X_i$和$X_{ancestors}|X_{parents}$独立 $P(B,E,A,R,C)$ $=P(B)P(E|B)P(A|B,E)P(R|A,B,E)P(C|R,A,B,E)$ $=P(B)P(E)P(A|B,E)P(R|E)P(C|A)$
DAG能够告诉我们 如果我们有n个变量$x_i$,那么这些变的联合概率分布可以拆解为: $P(X_{1:n})=P(x_1,x_2,\cdots,x_n)=\prod_{i=1}^nP(x_i|parents(x_i))$
概率图模型求法 # 概率图模型的求法: 消元法 aka(动态规划) aka(分配律) 动态规划的思想在: 概率图模型, HMM, VC-dimension, RL中的MDP, 神经网络BP中的DP 这几块用过</description></item><item><title>机器学习-视频学习系列12-聚类</title><link>/posts/machine_learning/ml_video12_aggregation/</link><pubDate>Fri, 07 Jun 2019 16:02:35 +0000</pubDate><guid>/posts/machine_learning/ml_video12_aggregation/</guid><description>聚类 # 基于对象的聚类(Objective based clustering) # K-means 聚类 # k-means 问题描述: 找到cpt1,cpt2,&amp;hellip;.cpt, 使 $ min\sum_{i=1}^n m_{j \in 1 \cdots k} d^2(x^i,c_j) $ k-median 问题描述: 找到cpt1,cpt2,&amp;hellip;.cpt, 使 $ min\sum_{i=1}^n m_{j \in 1 \cdots k} d(x^i,c_j) $ k-center 问题描述: 找到一个分类方式最小化最大半径 Lloyds method: 总是收敛的(目标函数单调递减,并且有下界, 该方法一定收敛) # 问题描述:
Input: 一组数据集 $ x^1, x^2, \cdots, x^n \in R^d$ Initialize: 1. 中心点 $c_1, c_2, \cdots, c_k \in R^d$ 2. 簇$C_1,C_2,\cdots,C_k$以随机方式聚合 Repeat:直到目标函数没有任何变化 1. for each j: $C_j \in {x \in S }$ where closest center is $c_j$ 2.</description></item></channel></rss>