<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/tags/java/"><meta property="og:title" content="Java"><meta property="og:locale" content="en"><meta property="og:type" content="website"><title>Java | </title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=/tags/java/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.8aa13e2f4b9fdd1fa1c269db82d4ba6bb2746e64391b4052adb11ab4309caef3.js></script><link rel=alternate type=application/rss+xml href=/tags/java/index.xml title></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Java</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul><li class="flex justify-between"><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>4</span></li><li class="flex justify-between"><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/>机器语言</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/class%E6%96%87%E4%BB%B6/>Class文件</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/java/>Java</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/jvm/>JVM</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/>监控工具</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/>类装载器</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gc/>GC</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/>隐马尔可夫</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/>贝叶斯网络</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%81%9A%E7%B1%BB/>聚类</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%A7%86%E9%A2%91/>视频</a>
<span>1</span></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=/posts/java/java_class_file_analysis/>Java Class文件结构</a></h2><h5>August 1, 2019</h5><div><a href=/tags/jvm/>JVM</a>,
<a href=/tags/java/>Java</a>,
<a href=/tags/class%E6%96%87%E4%BB%B6/>Class文件</a></div><p>语言无关性 # graph LR A(*.java)-->D(.class) B(*.rb)-->D C(*.groovy)-->D E(其它JVM语言)-->D D-->F(JVM) 文件结构 # u1 = 1byte
类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count-1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count magic u4 # 0xCAFEEBABE constant_pool_count u2 # 常量池中, 常量的个数
<a href=/posts/java/java_class_file_analysis/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_lock/>JVM锁</a></h2><h5>July 20, 2019</h5><div><a href=/tags/jvm/>JVM</a>,
<a href=/tags/java/>Java</a></div><p>线程安全 # 多线程网站统计访问人数 # 使用锁, 维护计数器的串行访问与安全性 多线程方位ArrayList public static List&lt;Integer> numberList = new ArrayList&lt;Integer>(); public static class AddToList implements Runnable{ int startnum=0; public AddToList(int startnumber){ startnum=startnumber; } @Override public void run(){ int count=0; while(count&lt;1000000){ numberList.add(startnum); startnum+=2; count++; } } } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(new AddToList(0)); Thread t2 = new Thread(new AddToList(1)); t1.start(); t2.start(); while(t1.isAlive()||t2.isAlive()){ Thread.sleep(1); } System.out.println(numberList.size()); } 对象头Mark # Mark Word , 对象头的标记, 32位 描述对象的hash, 锁信息, 垃圾回收标记, 年龄 指向锁记录的指针 指向monitor的治身 GC标记 偏向锁线程ID 偏向锁 # 大部分情况是没有竞争的, 所以可以通过偏向来提高性能 所谓偏向, 就是偏心, 即锁会偏向于当前已经占有锁的线程 将对象头Mark标记设置为偏向, 并将线程ID写入对象头Mark 只要没有竞争, 获得偏向锁的线程,在将来进入同步块,不需要做同步 当其他线程请求相同的锁时, 偏向模式结束 -XX:+UseBiasedLocking 默认启用 在竞争激烈的场合, 偏向锁会增加系统负担 // -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 public static List&lt;Integer> numberList = new Vector&lt;Integer>(); public static voi main(String[] args) throws InterruptedException { long begin = System.
<a href=/posts/java/jvm_lock/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_heap_analysis/>Java堆分析</a></h2><h5>July 14, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a></div><p>MAT使用基础 Memory Analyse Tool # 浅堆(Shallow Heap) # 一个对象结构所占用的内存大小 3个int类型以及一个引用类型合计占用3*4+4=16字节, 再加上对象头的8个字节,因此String对象占用的控件,即浅堆的大小是16+8=24字节 对象大小按照8字节对齐 浅堆大小和对象的内容无关, 只和对象的结构有关 深堆(Retained Heap) # 一个对象被GC后,可以真实释放的内存大小 只能通过对象访问到的(直接或者间接)所有对象和浅堆之和(支配树) 显示入引用(incoming)和出引用(outgoing) # 支配树 # 对象引用图中, 所有指向对象B的路径都经过对象A, 则认为对象A支配对象B 如果对象A是离对象B最近的一个支配对象,则认为对象A为对象B的直接支配者 支配者被回收, 被支配者也被回收 对象引用图 # graph TD A((A))-->C((C)) B((B))-->C C-->D((D)) C-->E((E)) E-->G((G)) G-->H((H)) D-->F((F)) F-->D F-->H 支配树 # graph TD root((root))-->A((A)) root-->B((B)) root-->C((C)) C-->D((D)) C-->E((E)) C-->H((H)) D-->F((F)) E-->G((G))</p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_performance_monitor/>JVM性能监控工具</a></h2><h5>July 13, 2019</h5><div><a href=/tags/jvm/>JVM</a>,
<a href=/tags/java/>Java</a>,
<a href=/tags/%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/>监控工具</a></div><p>系统性能监控 # uptime 系统时间 运行时间 连接数: 每个终端算一个连接数 1/5/15分钟系统平均负载 top 第一行同uptime cpu内存 每个进程占CPU的情况 vmstat 可以统计系统的CPU, 内存, swap, io等情况 CPU占用率很高, 上下文切换频繁, 说明系统有线程正在频繁切换 pidstat 细致观察进程 需要安装 监控CPU 监控IO 监控内存 Java自带工具 # jdk安装目录下的tools目录下.
jps # 列出java进程, 类似ps命令 -q指定jps只输出进程ID, 不输出类的短名称 -m输出传递给Java进程(主函数)的参数 -l可以用于输出主函数的完整路径 -v可以显式传递给JVM的参数 jinfo # 可以用来查看正在运行的Java应用程序的扩展参数, 甚至支持在运行时,修改部分参数 -flag &lt;name> : 打印指定的JVM的参数值 -flag [+|-] &lt;name>: 指定JVM参数的布尔值 -flag &lt;name>=&lt;value>: 设置指定JVM参数的值 # 显示新生代对象晋升到老年代对象的最大年龄 jinfo -flag MaxTenuringThreshold 2972 -XX:MaxTenuringThreshold=15 # 显示是否打印GC详细信息 jinfo -flag PrintGCDetails 2972 -XX:-PrintGCDetails # 运行时修改参数, 控制是否输出GC日志 jinof -flag PrintGCDetails 2972 -XX:-PrintGCDetails jinfo -flag +PrintGCDetails 2972 jinfo -flag PrintGCDetails 2972 -XX:+PrintGCDetails jmap # 生成Java应用程序的堆快照和对象的统计信息 jmap -histo 2972 >c:\s.
<a href=/posts/java/jvm_performance_monitor/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/java_class_loader/>Java 类装载器</a></h2><h5>July 9, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/>类装载器</a></div><p>class装载验证流程 # 加载 # 装载类的第一阶段 取得类的二进制流 转为方法区数据结构 在Java堆中生成对应的java.lang.Class对象 链接 # 验证 # 目的: 保证Class流的格式是正确的
文件格式的验证 持否以0xCAFEBABE开头 版本号时候合理 元数据验证 是否有父类 继承了final类? 非抽象类是否实现了所有的抽象方法 字节码验证(很复杂) 运行检查 栈数据类型和操作码数据参数吻合 跳转指令指定到合理的位置 符号引用验证 常量池中描述类是否存在 访问的方法或字段是否存在且有足够的权限 准备 # 分配内存,并为类设置初始值(方法区中) public static int v=1 在准备阶段中, v会被设置为0 在初始化的clinit中才会被设置为1 对于static final类型, 在准备阶段就会被赋为正常的值 public static final int v=1 解析 # 符号引用替换为直接引用 符号引用: 字符串引用对象不一定被加载 直接引用: 指针或者地址偏移量, 引用对象一定在内存 初始化 # 执行类构造器clinit static变量 赋值语句 static{}语句 子类的clinit调用前保证父类的clinit被调用 clinit是线程安全的 什么是类装载器ClassLoader # ClassLoader是一个抽象类 ClassLoader的实例将读入Java字节码将类装载到JVM中 ClassLoader可以定制,满足不同的字节码流获取方式 ClassLoader负责类装在过程中的加载阶段 ClassLoader的重要方法 # //载入并返回一个Class public Class&lt;?
<a href=/posts/java/java_class_loader/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/java_gc_params/>Java GC参数</a></h2><h5>July 9, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/gc/>GC</a></div><p>堆回顾 # 串行收集器 # 最古老, 最稳定 效率高 可能会产生较长的停顿 -XX:+UseSerialGC 新生代,老年代使用串行回收 新生代复制算法 老年代标记-压缩 并行收集器 # ParNew -XX:+UseParNewGC 新生代并行,老年代串行 Serial收集器新生代的并行版本 复制算法 多线程,需要多核支持 -XX:ParallelGCThreads 限制线程数量 Parallel收集器 类似ParNew 新生代复制算法 老年代 标记-压缩 更加关注吞吐量 -XX:+UseParallelGC 使用Parallel收集器+老年代串行 -XX:+UseParallelOldGC 使用Parallel收集器+并行老年代 -XX:MaxGCPauseMills 最大停顿时间, 单位毫秒 尽力保证回收时间不超过设定值 -XX:GCTimeRatio 0-100取值范围, 垃圾收集时间占总时间的比,默认99即最大允许1%时间做GC 以上两个指标是矛盾的, 不能对停顿时间和吞吐量同时长调优 CMS收集器 # Concurrent Mark Sweep 并发标记清除 标记-清除算法 与标记-压缩相比 并发阶段会降低吞吐量 老年代收集器(新生代使用ParNew) -XX:+UseConcMarkSweepGC CMS运行过程复杂, 着重实现了标记的过程, 可分为 初始标记 根可以直接关联到对象, 速度快 并发标记(和用户线程一起) 主要标记过程,标记全部对象 重新标记 由于并发标记时,用户线程依然运行, 在正式清理之前,再做修正 并发清除(和用户线程一起) 基于标记结果,直接清理对象 特点 尽可能降低停顿 会影响系统整体吞吐量和性能 清理不彻底 因为和用户线程一起执行,不能在空间快满时再清理 -XX:CMSInitiatingOccupancyFraction 设置触发GC的阈值 使用串行收集器作为后备 有关碎片 标记-清除 会产生碎片 标记-压缩 -XX:+UseCMSCompactAtFullCollection Full GC后,进行一次整理 整理过程是独占的,会引起停顿时间变长 -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后,进行一次碎片整理 -XX:ParallelCMSThreads 设置CMS的线程数量 减轻GC压力 软件架构设计 代码如何写 堆空间的分配</p></article><article class="markdown book-post"><h2><a href=/posts/java/java_gc_algo_n_category/>Java GC算法与种类</a></h2><h5>July 9, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/gc/>GC</a></div><p>GC的概念 # java中,GC的对象是堆空间和永久区 GC算法 # 引用计数法 没有被java采用 # 通过引用计数来回收垃圾, 但是有问题:
引用和去引用伴随加法和减法,影响性能 很难处理循环引用的问题 标记清除 # 现代垃圾回收算法的思想基础. 将垃圾回收分为两个阶段:
标记阶段
在标记阶段,首先通过根节点, 标记所有从根节点开始的可达对象. 因此,未被标记的对象就是未被引用的垃圾对象 清除阶段 清除所有未被标记的对象 标记压缩 # 适用于存活对象比较多的场合. 在标记-清除算法的基础上做了一些优化. 首先要从根节点开始,对所有可达对象做一次标记. 但之后不是简单的清理未标记的对象,而是将所有的存活对象压缩到内存的一端. 之后清理边界外所有空间
复制算法 # 与标记-清除算法相比, 复制算法是一种相对高效的回收算法 不适用于存活对象较多的长河, 如老年代 将原有的内存空间分为两块. 每次只使用其中一块, 在垃圾回收时, 将正在使用的内存中的存活对象复制到未使用额内存块中, 之后, 清除正在使用的内存块中的所有对象, 交换两个内存的角色, 完成垃圾回收 最大的问题是: 空间浪费, 整合标记清理思想 分代思想 # 根据对象的存活周期进行分类, 短命对象归为新生代, 长命对象归为老年代 根据不同代的特点, 选取合适的回收算法 少量对象存活,适合复制算法 大量对象存活,适合标记清理或者标记压缩 可触及性 # 所的算法, 需要能够识别一个垃圾对象, 因此需要给出一个可触及性的定义
可触及的: 从根节点可以触及到这个对象 可复活的: 一旦所有引用被释放,就是可复活状态, 因为在finalize()中可能复活该对象 不可触及的: 在finalize()后,可能会进入不可触及状态, 不可触及的对象不可能复活, 可以回收 /* finalize方法只会被调用一次 */ public class CanReliveObj{ public static CanReliveObj obj; @Override protected void finalize() throws Throwable { super.
<a href=/posts/java/java_gc_algo_n_category/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_common_opts/>JVM常用运行参数</a></h2><h5>July 8, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a>,
<a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a></div><p>Trace跟踪参数 # -verbose:gc -XX:+PrintGC 可以打印GC的简要信息 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印GC发生的时间戳 -Xloggc:log/gc.log 指定GC log的位置,以文件输出, 帮助开发人员分析问题 -XX:+PrintHeapAtGC 每一次GC后,都打印堆信息 -XX:+TraceClassLoading 监控类的加载 -XX:+PrintClassHistogram 按下Ctrl+Break后, 打印类的信息. 分别显示的是: 序号, 实例数量, 总大小, 类型 堆的分配参数 # -Xmx 最大堆 -Xms 最小堆 System.out.print("Xmx="); System.out.println(Runtime.getRuntime().maxMemory()/1024/1024 + "M"); System.out.print("free mem="); System.out.println(Runtime.getRuntime().freeMemory()/1024/1024 + "M"); System.out.print("total mem="); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024 + "M"); -Xmn 设置新生代大小,是一个绝对值 -XX:NewRatio 按比例设置新生代的比例: 新生代(eden + 2*s)和老年代(不包含永久区)的比值. 例如: 4表示 新生代:老年代=1:4, 即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比. 例如: 8表示 两个Survivor:eden = 2:8, 即一个Survivor占年轻代的1/10 /* 通过设置不同的JVM参数观察GC的情况: 合理减少幸存代大小提高GC效率, 减少GC -Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetail 不会触发GC,全部分配在老年代 -Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 不会触发GC,全部分配在eden,老年代没有使用 -Xmx20m -Xms20m -Xmn7m -XX:+PrintGCDetails 进行了2次新生代GC, s0,s1太小需要老年代担保 -Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 进行了3次新生代GC, s0,s1增大 -Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2-XX:+PrintGCDetails */ public static void main(String[] args){ byte[] b= null; for(int i=0;i&lt;10;i++){ b = new byte[1*1024*1024]; } } -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 导出OOM的路径 /* -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.
<a href=/posts/java/jvm_common_opts/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/java/jvm_basics/>JVM运行机制</a></h2><h5>July 8, 2019</h5><div><a href=/tags/java/>Java</a>,
<a href=/tags/jvm/>JVM</a></div><p>JVM运行机制 # PC寄存器 # 每个线程拥有一个PC寄存器 在线程创建时创建 总是指向下一条指令的地址 执行本地方法时, PC的值为undefined 方法区 # 保存装载的类信息 类型的常量池 字段, 方法信息 方法字节码 通常和永久区关联在一起 java堆 # 和程序开发密切相关 应用系统对象都保存在java堆中 所有线程共享java堆 对分代GC来说, 堆也是分代 GC的主要工作区间: eden|s0|s1|tenured java栈 # 线程私有 栈由一系列帧组成(因此java栈也叫做栈帧) 帧保存一个方法的局部变量,操作数栈,常量池指针 每一次方法调用创建一个帧,并压栈 java栈之局部变量表(包含参数和局部变量) # public class StackDemo { /* 假设局部变量表里是一个槽位, 每个槽位最大容纳32位的数据*/ /* 静态方法的局部变量表为: 0 int int i 1 long long l 2 float float f 3 reference Object o 4 int byte b */ public static int run Static(int i, long l, float f, Object o, byte b){ return 0; } /* 实例方法的局部变量表为: 0 reference this 当前对象的引用 1 int char c 2 int short s 3 int boolean bµ */ public int runInstance(char c, short s, boolean b){ return 0; } } java栈之函数调用组成帧栈(包括操作数栈和返回地址) # /* 函数调用过程, 会压栈 */ public static int runStatic(int i, long l, float f, Object o, byte b){ return runStatic(i, l, f, o, b); } java栈之操作数栈 # /* java没有寄存器, 所有参数传递使用操作数栈 以下方法的操作数栈情况: 0 iconst_0 0压栈 1 istore_2 弹出int,存放于局部变量2 2 iload_0 把局部变量0压栈 3 iload_1 把局部变量1压栈 4 iadd 弹出2个变量,求和,结果压栈 5 istore_2 弹出结果,放于局部变量2 6 iload_2 局部变量2压栈 7 ireturn 返回 */ public static int add(int a, int b){ int c = 0; c = a + b; return c; } java栈之栈上分配 # class BcmBasicString{.
<a href=/posts/java/jvm_basics/>...</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul><li class="flex justify-between"><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>4</span></li><li class="flex justify-between"><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/>机器语言</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/class%E6%96%87%E4%BB%B6/>Class文件</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/java/>Java</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/jvm/>JVM</a>
<span>9</span></li><li class="flex justify-between"><a href=/tags/%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/>监控工具</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8/>类装载器</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gc/>GC</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/>参数调优</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/>隐马尔可夫</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/>贝叶斯网络</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%81%9A%E7%B1%BB/>聚类</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/%E8%A7%86%E9%A2%91/>视频</a>
<span>1</span></li></ul></li></ul></nav></div></aside></main></body></html>